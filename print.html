<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Counterexamples in Type Systems</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <!-- KaTeX stylesheet -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

<style>
pre[data-codetab=hide] { display: none; }
pre[data-codetab] { margin-top: 0 }
.error { color: #f00; }
.codetab-bar button {
  background-color: inherit;
  border: none;
  cursor: pointer;
}
.codetab-bar button:hover {
  background-color: #ddd;
}
.codetab-bar button[data-codetab=show] {
  background-color: #ccc;
}
</style>

<script>
function langName(node) {
  let lang = node.querySelector('code[class^="language-"]');
  if (lang) lang = lang.className.match(/language-(\w+)/)[1];
  lang = lang ? lang : "code";
  lang = lang.replace(/^\w/, s => s.toUpperCase());
  lang = {Ocaml:"OCaml","_rust":"Rust","Sml":"Standard ML","Typescript":"TypeScript","Csharp":"C#"}[lang] || lang;
  return lang;
}
function insertCodeTabs() {
  while (true) {
    let code = document.querySelector('pre:not([data-codetab])');
    if (!code) return;
    let bar = document.createElement("DIV");
    bar.classList.add('codetab-bar');
    let tabs = [], buttons = [];
    while (code && code.nodeName == "PRE") {
      let button = document.createElement('BUTTON');
      button.innerHTML = langName(code);
      tabs.push(code);
      buttons.push(button);
      bar.appendChild(button);
      code = code.nextElementSibling;
    }
    tabs[0].parentNode.insertBefore(bar, tabs[0]);
    let select = function(t,b) {
      tabs.forEach(t => t.dataset.codetab="hide");
      buttons.forEach(b => b.dataset.codetab="hide");
      t.dataset.codetab = "show";
      b.dataset.codetab = "show";
    };
    for (var i = 0; i < tabs.length; i++) {
      let ix = i;
      buttons[ix].addEventListener('click', ev => select(tabs[ix], buttons[ix]));
    }
    select(tabs[0], buttons[0]);
  }
}
document.addEventListener('DOMContentLoaded', insertCodeTabs);
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 450) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Counterexamples in Type Systems</a></li><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="glossary.html">Index and Glossary</a></li><li class="chapter-item expanded "><a href="polymorphic-references.html"><strong aria-hidden="true">1.</strong> Polymorphic references</a></li><li class="chapter-item expanded "><a href="general-covariance.html"><strong aria-hidden="true">2.</strong> Covariant containers</a></li><li class="chapter-item expanded "><a href="incomplete-variance.html"><strong aria-hidden="true">3.</strong> Incomplete variance checking</a></li><li class="chapter-item expanded "><a href="under-construction.html"><strong aria-hidden="true">4.</strong> Objects under construction</a></li><li class="chapter-item expanded "><a href="currys-paradox.html"><strong aria-hidden="true">5.</strong> Curry's paradox</a></li><li class="chapter-item expanded "><a href="eventually-nothing.html"><strong aria-hidden="true">6.</strong> Eventually, nothing</a></li><li class="chapter-item expanded "><a href="dubious-evidence.html"><strong aria-hidden="true">7.</strong> Dubious evidence</a></li><li class="chapter-item expanded "><a href="anythings.html"><strong aria-hidden="true">8.</strong> Some kinds of Anything</a></li><li class="chapter-item expanded "><a href="anything-once.html"><strong aria-hidden="true">9.</strong> Any (single) thing</a></li><li class="chapter-item expanded "><a href="mutable-matching.html"><strong aria-hidden="true">10.</strong> Mutable matching</a></li><li class="chapter-item expanded "><a href="runtime-misinformation.html"><strong aria-hidden="true">11.</strong> Runtime type misinformation</a></li><li class="chapter-item expanded "><a href="overloading-polymorphism.html"><strong aria-hidden="true">12.</strong> Overloading and polymorphism</a></li><li class="chapter-item expanded "><a href="distinctness-injectivity.html"><strong aria-hidden="true">13.</strong> Distinctness I: Injectivity</a></li><li class="chapter-item expanded "><a href="distinctness-recursion.html"><strong aria-hidden="true">14.</strong> Distinctness II: Recursion</a></li><li class="chapter-item expanded "><a href="distinctness-options.html"><strong aria-hidden="true">15.</strong> Distinctness III: Options</a></li><li class="chapter-item expanded "><a href="subtyping-vs-inheritance.html"><strong aria-hidden="true">16.</strong> Subtyping vs. inheritance</a></li><li class="chapter-item expanded "><a href="selfishness.html"><strong aria-hidden="true">17.</strong> Selfishness</a></li><li class="chapter-item expanded "><a href="privacy-violation.html"><strong aria-hidden="true">18.</strong> Privacy violation</a></li><li class="chapter-item expanded "><a href="unstable-types.html"><strong aria-hidden="true">19.</strong> Unstable type expressions</a></li><li class="chapter-item expanded "><a href="avoidance.html"><strong aria-hidden="true">20.</strong> The avoidance problem</a></li><li class="chapter-item expanded "><a href="little-knowledge.html"><strong aria-hidden="true">21.</strong> A little knowledge...</a></li><li class="chapter-item expanded "><a href="underdetermined-recursion.html"><strong aria-hidden="true">22.</strong> Underdetermined recursion</a></li><li class="chapter-item expanded "><a href="overdetermined-recursion.html"><strong aria-hidden="true">23.</strong> Overdetermined recursion</a></li><li class="chapter-item expanded "><a href="scope-escape.html"><strong aria-hidden="true">24.</strong> Scope escape</a></li><li class="chapter-item expanded "><a href="false-pretenses.html"><strong aria-hidden="true">25.</strong> Under false pretenses</a></li><li class="chapter-item expanded "><a href="suspicious-subterms.html"><strong aria-hidden="true">26.</strong> Suspicious subterms</a></li><li class="chapter-item expanded "><a href="only-one-leibniz.html"><strong aria-hidden="true">27.</strong> There's only one Leibniz</a></li><li class="chapter-item expanded "><a href="intersecting-references.html"><strong aria-hidden="true">28.</strong> Intersecting references</a></li><li class="chapter-item expanded "><a href="polymorphic-union-refinement.html"><strong aria-hidden="true">29.</strong> Polymorphic union refinement</a></li><li class="chapter-item expanded "><a href="strict-positivity.html"><strong aria-hidden="true">30.</strong> Positivity, strict and otherwise</a></li><li class="chapter-item expanded "><a href="nearly-universal.html"><strong aria-hidden="true">31.</strong> Nearly-universal quantification</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Counterexamples in Type Systems</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/stedolan/counterexamples" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#counterexamples-in-type-systems" id="counterexamples-in-type-systems">Counterexamples in Type Systems</a></h1>
<p><em>collated by Stephen Dolan, with thanks to Andrej Bauer, Leo White and Jeremy Yallop</em></p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to <em>Counterexamples in Type Systems</em>, a compendium of horrible
programs that crash, segfault or otherwise explode.</p>
<p>The &quot;counterexamples&quot; here are programs that go wrong in ways that
should be impossible: corrupt memory in Rust, produce a
<code>ClassCastException</code> in cast-free Java, segfault in Haskell, and so
on. This book is a collection of such counterexamples, each with some
explanation of what went wrong and references to the languages or
systems in which the problem occurred.</p>
<p>It's intended as a resource for researchers, designers and
implementors of static type systems, as well as programmers interested
in how type systems fit together (or don't).</p>
<h2><a class="header" href="#type-systems" id="type-systems">Type systems</a></h2>
<p>For the purposes of this book, a &quot;type system&quot; is a system that does
local checks of a program's source code, in order to establish some
global property about the program's behaviour. The local checks
usually assign a type to each variable and verify that they are used
only in contexts appropriate to their type, while the global property
varies but is generally some sort of safety property: the absence of
memory corruption, use-after-free errors, and the like.</p>
<p>This is intentionally a fairly narrow definition. Some examples of
things that are not &quot;type systems&quot;:</p>
<ul>
<li>
<p><strong>Linters</strong>: Linters do local checks of a programs's source code,
but don't try to establish any global property. Just because a
program passes a linter's checks does not imply anything definite
about its behaviour.</p>
</li>
<li>
<p><strong>Python's type system</strong>: Dynamic languages like Python do local
type checks to establish global safety properties. However, the
type checks are not done purely on the program's source code
before running it, but examine the actual runtime inputs as well.</p>
</li>
<li>
<p><strong>C++'s type system</strong>: C++ (among other unsafe languages) has a
type system that does many local checks of a programs's source
code. However, passing these checks does not establish anything
definite about a program's behaviour: many C++ programs pass all
of the compiler's type checking, and yet exhibit use-after-free
errors, memory corruption, and arbitrary behaviour when run.</p>
</li>
<li>
<p><strong>Some program analysis tools</strong>: Some static program analysis
tools do only global checks (requiring the whole program's source
code to be available at once), while others detect certain issues
but do not attempt to establish any global property when no issues
are found. Still others do fit the definition of &quot;type system&quot;,
though: the line here is blurry.</p>
</li>
</ul>
<p>This is not to say that there's something wrong with the above tools,
but they're not what this book is about. Some examples of things that
do fit the definition are the type systems of languages like Java,
Haskell and Rust.</p>
<h2><a class="header" href="#soundness-and-counterexamples" id="soundness-and-counterexamples">Soundness and counterexamples</a></h2>
<p>Type systems make the claim that any program that passes the local
type checks will definitely have the global safety properties. A type
system is <em>sound</em> if this claim is true, and to say that a system is
<em>unsound</em> is to say that there exists some program which passes all
type checks, and yet whose behaviour violates the global safety
properties (corrupts memory, crashes unexpectedly, etc.). A
<em>counterexample</em> is such a program, exhibiting a <em>soundness bug</em>.</p>
<p>Different languages enforce different properties, so exactly what
&quot;soundness&quot; means varies somewhat. For instance, a global property
established by the Coq type system is that all programs halt. So, a
program that looped infinitely would be a counterexample in Coq, but
not in Java, which makes no such claim.</p>
<p>The goal of this book is to collect such counterexamples, especially
those that crop up in similar forms across multiple languages. These
fall into a couple of broad categories:</p>
<ul>
<li>
<p><strong>Missing checks</strong>: The simplest sort of soundness bug is when some
important type check is missing from the type checker. Usually,
these are straightforward bugs, easily fixed once discovered,
highly specific to a particular compiler, and not very interesting.
However, certain missing checks are common mistakes that keep
coming up across many different type checkers and languages, and a
few of these are included here: for instance, missing <a href="incomplete-variance.html">variance
checks</a> or <a href="scope-escape.html">scope checks</a>.</p>
</li>
<li>
<p><strong>Feature interactions</strong>: Often, two type system features which are
perfectly sound when used in isolation have some tricky
interaction when used together. Examples of this include mixtures
of <a href="polymorphic-references.html">polymorphism and mutability</a> or
<a href="overloading-polymorphism.html">polymorphism and overloading</a> or
<a href="intersecting-references.html">intersections and mutability</a>.</p>
</li>
<li>
<p><strong>Subtle differences</strong>: If two parts of a type system use different
but similar versions of the same concept, the gap between them can
often cause soundness bugs. For instance, does &quot;private&quot; mean
<a href="privacy-violation.html">private to an object or private to a class</a>?
Does &quot;unequal&quot; mean <a href="distinctness-injectivity.html">&quot;not provably equal&quot; or &quot;provably
distinct&quot;</a>?</p>
</li>
</ul>
<h2><a class="header" href="#organisation-or-lack-thereof" id="organisation-or-lack-thereof">Organisation (or lack thereof)</a></h2>
<p>Since so many of the counterexamples here depend on interactions
between disparate parts of a complex type system, it would be tricky
to separate them all into distinct coherent topics, and no attempt to
do so has been made.</p>
<p>Instead, each entry is tagged with the type system features involved,
and in lieu of a table of contents there is an <a href="glossary.html">index and
glossary</a> listing the features and the counterexamples in
which they appear.</p>
<p>The entries themselves are mostly independent, and it should be
possible to read them in any order. However, a few of them do refer to
previous entries, and some attempt was made to put the simpler entries
earlier, so if you do intend to read the whole thing then going start
to finish is best.</p>
<h2><a class="header" href="#a-note-on-sources" id="a-note-on-sources">A note on sources</a></h2>
<p>While much type system research appears in formal academic
publications, it is relatively rare (but not unheard of!) to publish a
paper about an unsound system.</p>
<p>So, as well as academic papers, many of the counterexamples here are
drawn from unpublished notes, the archives of the
<a href="https://lists.seas.upenn.edu/mailman/listinfo/types-list">TYPES</a>
forum, blogs by programming language researchers, designers and
implementors, and language-specific bugtrackers, forums and mailing
lists.  A major reason for the existence of this book is to collect
these various sources together.</p>
<p>In particular, compiler bugtrackers are a major source of the
counterexamples reproduced here. Try not to read too much into how
often different bugtrackers show up: while it is tempting to assume
that the more often a compiler appears, the buggier it is, this would
be wrong for several reasons:</p>
<ul>
<li>
<p>the author works professionally on OCaml, so it is somewhat
over-represented due to familiarity,</p>
</li>
<li>
<p>the same applies to other languages that the author likes or at
least vaguely understands, and</p>
</li>
<li>
<p>languages whose community does a good job of publicly tracking,
explaining, and writing up issues that arise are also
over-represented.</p>
</li>
</ul>
<h1><a class="header" href="#index-and-glossary" id="index-and-glossary">Index and Glossary</a></h1>
<h3><a class="header" href="#polymorphism" id="polymorphism">Polymorphism</a></h3>
<p>The word &quot;polymorphism&quot; can refer to several different things. Here,
it means &quot;parametric polymorphism&quot;: types like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">∀α .; α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>,
allowing the same value to be used at many possible types,
parameterised by a type variable. This feature is sometimes called
&quot;generics&quot;.</p>
<p>Other meanings include &quot;subtype polymorphism&quot; (see
<a href="glossary.html#subtyping">subtyping</a>) and &quot;ad-hoc polymorphism&quot; (see
<a href="glossary.html#overloading">overloading</a>).</p>
<ul>
<li><a href="polymorphic-references.html">Polymorphic references</a></li>
<li><a href="anythings.html">Some kinds of Anything</a></li>
<li><a href="anything-once.html">Any (single) thing</a></li>
<li><a href="overloading-polymorphism.html">Overloading and polymorphism</a></li>
<li><a href="scope-escape.html">Scope escape</a></li>
<li><a href="polymorphic-union-refinement.html">Polymorphic union refinement</a></li>
<li><a href="nearly-universal.html">Nearly-universal quantification</a></li>
</ul>
<h3><a class="header" href="#subtyping" id="subtyping">Subtyping</a></h3>
<p>Subtyping allows a value of a more specific type to be supplied where
a value of a more general type was expected, without the two types
having to be exactly equal.</p>
<ul>
<li><a href="general-covariance.html">Covariant containers</a></li>
<li><a href="incomplete-variance.html">Incomplete variance checking</a></li>
<li><a href="anythings.html">Some kinds of Anything</a></li>
<li><a href="subtyping-vs-inheritance.html">Subtyping vs. inheritance</a></li>
<li><a href="selfishness.html">Selfishness</a></li>
<li><a href="privacy-violation.html">Privacy violation</a></li>
<li><a href="avoidance.html">The avoidance problem</a></li>
<li><a href="intersecting-references.html">Intersecting references</a></li>
<li><a href="nearly-universal.html">Nearly-universal quantification</a></li>
</ul>
<h3><a class="header" href="#overloading" id="overloading">Overloading</a></h3>
<p>An <em>overloaded function</em> has several different versions all with the
same name, where the language picks the right one to call by examining
the types of its arguments at each call site.</p>
<ul>
<li><a href="overloading-polymorphism.html">Overloading and polymorphism</a></li>
</ul>
<h3><a class="header" href="#recursive-types" id="recursive-types">Recursive types</a></h3>
<p>Recursive types are types whose definition refers to themselves,
either by using their own name during their definition, or by using
explicit fixpoint operators like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">μ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span>-types.</p>
<ul>
<li><a href="incomplete-variance.html">Incomplete variance checking</a></li>
<li><a href="currys-paradox.html">Curry's paradox</a></li>
<li><a href="distinctness-recursion.html">Distinctness II: Recursion</a></li>
<li><a href="underdetermined-recursion.html">Underdetermined recursion</a></li>
<li><a href="overdetermined-recursion.html">Overdetermined recursion</a></li>
<li><a href="strict-positivity.html">Positivity, strict and otherwise</a></li>
</ul>
<h3><a class="header" href="#variance" id="variance">Variance</a></h3>
<p>Types that take parameters (like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span>) may have subtyping
relationships that depend on the subtyping relationships of their
parameters: for instance, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> is a subtype of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[B]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span></span></span></span>
only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> is a subtype of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. The manner in which the parameter's
subtyping affects the whole type's subtyping is called <em>variance</em>.</p>
<ul>
<li><a href="general-covariance.html">Covariant containers</a></li>
<li><a href="incomplete-variance.html">Incomplete variance checking</a></li>
<li><a href="privacy-violation.html">Privacy violation</a></li>
</ul>
<h3><a class="header" href="#mutation" id="mutation">Mutation</a></h3>
<p>The presence of mutable values (reference cells, mutable arrays, etc.)
in a language means that there are expressions which, when evaluated
twice, yield different values both times (which can have consequences
for the type system).</p>
<ul>
<li><a href="polymorphic-references.html">Polymorphic references</a></li>
<li><a href="under-construction.html">Objects under construction</a></li>
<li><a href="mutable-matching.html">Mutable matching</a></li>
<li><a href="unstable-types.html">Unstable type expressions</a></li>
<li><a href="intersecting-references.html">Intersecting references</a></li>
</ul>
<h3><a class="header" href="#scoping" id="scoping">Scoping</a></h3>
<p>When types are types defined locally to a module, function or
block, the compiler must check do not accidentally leak out
of their scope.</p>
<ul>
<li><a href="avoidance.html">The avoidance problem</a></li>
<li><a href="scope-escape.html">Scope escape</a></li>
</ul>
<h3><a class="header" href="#typecase" id="typecase">Typecase</a></h3>
<p><em>Typecase</em> refers to any runtime test that checks types. Several other
names for this feature exist: <code>instanceof</code>, downcasting, matching on types.</p>
<ul>
<li><a href="incomplete-variance.html">Incomplete variance checking</a></li>
<li><a href="runtime-misinformation.html">Runtime type misinformation</a></li>
<li><a href="polymorphic-union-refinement.html">Polymorphic union refinement</a></li>
</ul>
<h3><a class="header" href="#empty-types" id="empty-types">Empty types</a></h3>
<p>An empty type is a type that has no values, and can represent the
return type of a function that never returns or the element type of a
list that is always empty. These are not to be confused with <em>unit
types</em> like C's <code>void</code> or Haskell's <code>()</code>, which are types that have a
single value (and consequently carry no <em>information</em>).</p>
<ul>
<li><a href="eventually-nothing.html">Eventually, nothing</a></li>
<li><a href="dubious-evidence.html">Dubious evidence</a></li>
<li><a href="false-pretenses.html">Under false pretenses</a></li>
</ul>
<h3><a class="header" href="#equality" id="equality">Equality</a></h3>
<p>Determining whether two types are equal is a surprisingly tricky
business, especially in a language with advanced type system features
(e.g. dependent types).</p>
<ul>
<li><a href="dubious-evidence.html">Dubious evidence</a></li>
<li><a href="false-pretenses.html">Under false pretenses</a></li>
<li><a href="only-one-leibniz.html">There's only one Leibniz</a></li>
</ul>
<h3><a class="header" href="#injectivity" id="injectivity">Injectivity</a></h3>
<p>A parameterised type like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> is said to be <em>injective</em> if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[A] = \n{List}[B]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span></span></span></span> implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. All, some or none of a
language's parameterised types may have this property.</p>
<ul>
<li><a href="distinctness-injectivity.html">Distinctness I: Injectivity</a></li>
</ul>
<h3><a class="header" href="#totality" id="totality">Totality</a></h3>
<p>In a <em>total</em> language, all programs terminate, and unbounded recursion
or infinite looping is impossible. Enforcing this property places a
significant extra burden on the type checker.</p>
<ul>
<li><a href="currys-paradox.html">Curry's paradox</a></li>
<li><a href="suspicious-subterms.html">Suspicious subterms</a></li>
<li><a href="strict-positivity.html">Positivity, strict and otherwise</a></li>
</ul>
<h3><a class="header" href="#abstract-types" id="abstract-types">Abstract types</a></h3>
<p>An abstract type is one whose implementation is hidden: the type may
in fact be implemented directly as another type, but this fact is not
exposed.</p>
<ul>
<li><a href="little-knowledge.html">A little knowledge...</a></li>
</ul>
<h3><a class="header" href="#impredicativity" id="impredicativity">Impredicativity</a></h3>
<p>A type system is <em>predicative</em> if definitions can never be referred
to, even indirectly,   before they are defined. In particular,
polymorphic types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">∀α. \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> are predicative only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> ranges over
types not including the polymorphic type being defined. Predicative
systems usually have restricted polymorphism (in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">∀α. \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> may
range only over types that do not themselves use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">∀</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span>, or there may be
a system of stratified levels of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">∀</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span>-usage). One hallmark of
impredicative systems is unrestricted <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">∀</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span> (present in e.g. System F)</p>
<ul>
<li><a href="strict-positivity.html">Positivity, strict and otherwise</a></li>
</ul>
<h1><a class="header" href="#polymorphic-references" id="polymorphic-references">Polymorphic references</a></h1>
<p><small><a href="glossary.html#polymorphism">[polymorphism]</a> <a href="glossary.html#mutation">[mutation]</a></small></p>
<p>Polymorphism, as found in ML and Haskell (and in C# and Java where
it's called &quot;generics&quot;) lets the same definition be reused with
multiple different unrelated types. For instance, here's a polymorphic
function that creates a single-element list:</p>
<pre><code class="language-ocaml">let singleton x = [x]
</code></pre>
<pre><code class="language-java">static &lt;A&gt; List&lt;A&gt; singleton(A x) {
    return Arrays.asList(x);
}
</code></pre>
<p>The same <code>singleton</code> function can be used to turn an integer into a
list of integers, and also to turn a string into a list of strings.</p>
<p>The standard typing rule for polymorphism is:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>A</mi></mrow></mfrac><mrow><mtext> if </mtext><mstyle scriptlevel="0" displaystyle="false"><mi>α</mi></mstyle><mtext> not free in </mtext><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="normal">Γ</mi></mstyle></mrow></mrow><annotation encoding="application/x-tex">
\frac{Γ ⊢ e : A}{Γ ⊢ e : ∀α . A} \text{ if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> not free in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">Γ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal">A</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord text"><span class="mord"> if </span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"> not free in Γ</span></span></span></span></span></span></p>
<p>That is, if an expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> has a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> which mentions a type
variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, and the type variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> is used only in the type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, then the value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> can be reused with different types
substituted for <nobr><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</nobr>
The justification is that different uses of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> can use different
types for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, since nothing outside the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> depends on which
type is chosen. This process is called <em>generalising</em> the type variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</p>
<p>But if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> can allocate mutable state (say, a mutable reference cell,
or a mutable array), then different uses of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> can share state:</p>
<pre><code class="language-ocaml">let r = ref [] in           (* r : ∀ α . α list ref *)
r := [0];                   (* using r as an int list ref *)
print_string (List.hd !r)   (* using r as a string list ref *)
(* Crash! (Well, it would, if the OCaml compiler allowed this) *)
</code></pre>
<p>One obvious-but-broken solution is to disallow polymorphism when the
type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> mentions types with mutable state. This doesn't work:
because functions can hide types in their closures, the problem occurs
even when the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> doesn't mention mutable state:</p>
<pre><code class="language-ocaml">let f =
  let r = ref None in
  fun x -&gt;
    match !r with
    | None -&gt; r := Some x; x
    | Some x -&gt; x
(* The value restriction means f is not polymorphic,
   but if it were then this would crash: *)
let _ =
  let _ = f 42 in
  print_string (f &quot;hello&quot;)
</code></pre>
<p>This problem originated in the ML family of languages, as these were
the first to combine mutable references and polymorphism. A related
problem appeared in Standard ML of New Jersey's implementation of
<code>call/cc</code><sup class="footnote-reference"><a href="#callcc">1</a></sup>, which like mutable references allows multiple uses of an
expression to share state (by sharing the continuation). Recently, an
instance of this problem arose in OCaml, due to an incorrect
typechecker refactoring<sup class="footnote-reference"><a href="#ocaml411">2</a></sup>. The problem has also appeared in
Elm<sup class="footnote-reference"><a href="#elm">3</a></sup>, using channels to provide the shared mutable state.</p>
<pre><code class="language-sml">(* Counterexample by Bob Harper and Mark Lillibridge *)
fun left (x,y) = x;
fun right (x,y) = y;

let val later = (callcc (fn k =&gt;
	(fn x =&gt; x,
         fn f =&gt; throw k (f, fn f =&gt; ()))))
in
	print (left(later)&quot;hello world!\n&quot;);
	right(later)(fn x =&gt; x+2)
end
</code></pre>
<pre><code class="language-ocaml">(* Counterexample by Thierry Martinez *)
let f x =
  let ref : type a . a option ref = ref None in
  ref := Some x;
  Option.get !ref

let () = print_string (f 0)
</code></pre>
<pre><code class="language-elm">-- Counterexample by Izaak Meckler
import Signal
import Html
import Html.Attributes(style)
import Html.Events(..)
import Maybe

c = Signal.channel Nothing

s : Signal Int
s = Signal.map (Maybe.withDefault 0) (Signal.subscribe c)

draw x =
  Html.div
  [ onClick (Signal.send c (Just &quot;I am not an Int&quot;))
  , style [(&quot;width&quot;, &quot;100px&quot;), (&quot;height&quot;, &quot;100px&quot;)]
  ]
  [ Html.text (toString (x + 1)) ]
  |&gt; Html.toElement 100 100

main = Signal.map draw s
</code></pre>
<p>There are several solutions:</p>
<ul>
<li>
<p><strong>Separate pure and effectful types</strong></p>
<p>The original solution chosen in Standard ML distinguishes
<em>applicative</em> type variables from <em>imperative</em> type variables.
Only applicative variables can be generalised, and only imperative
variables can be used in the type of mutable references. There are
several variants of this system, from Tofte's original one to
extensions used in SML/NJ by MacQueen and
others. Greiner<sup class="footnote-reference"><a href="#greiner">4</a></sup> has a survey of the variants.</p>
<p>This approach has the disadvantage that internal use of mutation
cannot be hidden: a polymorphic sorting function that internally
uses temporary mutable storage cannot be given the same type as
one that does not.</p>
<p>Leroy and Weis<sup class="footnote-reference"><a href="#leroy">5</a></sup> propose a related approach that avoids
generalising type variables that may be used in mutable
references, without needing to distinguish two classes of type
variables.  However, to avoid the issue above of functions hiding
types in their closure, their solution must distinguish two
different sorts of function type according to whether their
closure may contain mutable references.</p>
</li>
<li>
<p><strong>The value restriction</strong></p>
<p>A simpler solution was proposed by Wright<sup class="footnote-reference"><a href="#wright">6</a></sup> and is now used
in most implementations of ML: generalisation of an expression's
type only happens if the expression is a <em>syntactic value</em>, a
class that contains e.g. function definitions and tuple
constructions, but not function calls or anything that could
possibly allocate a mutable reference.</p>
<p>This solution is much simpler than the type-based approaches, but
in some cases less powerful: notably, a partial application of a
curried function cannot be generalised without manually eta-expanding.</p>
<p>In effect, this is also the solution used by e.g. Java and C#: in these
languages, only methods may be given generic types, not
fields. This ensures that generalisation only occurs on function
definitions.</p>
</li>
<li>
<p><strong>Effect typing</strong></p>
<p>Type-and-effect systems have a typing judgement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mtext> </mtext><mo stretchy="false">!</mo><mtext> </mtext><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e : A, !,
Δ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> is the <em>effect</em>, representing effects that occur as
part of evaluating <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>. The typing rule for polymorphism in such
systems can generalise a type variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> only if it does not
appear in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">Γ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span> <em>or</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>. If allocating a new mutable reference of
type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> results in an effect mentioning <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> appearing in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>,
then polymorphic mutable references cannot be created.</p>
</li>
<li>
<p><strong>Effect marking</strong></p>
<p>Instead of a full-blown type-and-effect system, polymorphic
mutable references can be avoided using a type-level marker on
computations that may perform any effects at all, and then
disabling polymorphism on effectful computations.</p>
<p>This is the approach taken by Haskell with its monadic encoding of
effectful computations in the type <code>IO a</code>. Values of this type
represent &quot;IO actions&quot; - computations that, when performed, yield
results of type <code>a</code>, possibly causing some side-effects as
well. Polymorphism is available as usual when constructing IO
actions, but the type of an IO action's result (as used in <code>do</code>
notation or via monadic combinators) cannot be generalised.
Haskell's <code>do</code> notation for monadic computation does support a
<code>let</code> syntax, but its typing is quite different from ordinary
<code>let</code>, and it does not allow introducing polymorphism even with an
explicit annotation.</p>
<p>This mechanism allows Haskell to distinguish the following two types:</p>
<pre><code class="language-haskell">good :: forall a . IO (IORef (Maybe a))
bad  :: IO (forall a . IORef (Maybe a))
</code></pre>
<p>Here, <code>good</code> is an IO action which allocates a mutable reference
of an arbitrary type (fine, implementable as <code>newIORef Nothing</code>),
while <code>bad</code> is an IO action which allocations a polymorphic
mutable reference (unsound). Note that the only distinction
between these two is the placement of <code>IO</code>.</p>
<p>This reliance on marking <code>IO</code> is why Haskell's <code>unsafePerformIO</code>
is actually unsafe, as it can be used to strip the <code>IO</code> marker and
create polymorphic mutable references:</p>
<pre><code class="language-haskell">import Data.IORef
import System.IO.Unsafe
badref :: IORef (Maybe a)
badref = unsafePerformIO (newIORef Nothing)
main = do
  writeIORef badref (Just 42)
  Just x &lt;- readIORef badref
  putStrLn (x 1)
</code></pre>
</li>
</ul>
<div class="footnote-definition" id="callcc"><sup class="footnote-definition-label">1</sup>
<p><a href="http://www.seas.upenn.edu/%7Esweirich/types/archive/1991/msg00034.html">ML with callcc is unsound</a> (TYPES mailing list) Bob Harper and Mark Lillibridge (1991)</p>
</div>
<div class="footnote-definition" id="ocaml411"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/9856">https://github.com/ocaml/ocaml/issues/9856</a> (2020)</p>
</div>
<div class="footnote-definition" id="elm"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/elm/compiler/issues/889">https://github.com/elm/compiler/issues/889</a> (2015)</p>
</div>
<div class="footnote-definition" id="greiner"><sup class="footnote-definition-label">4</sup>
<p><a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5096&amp;rank=1">Weak Polymorphism Can Be Sound</a>, John Greiner (1996)</p>
</div>
<div class="footnote-definition" id="leroy"><sup class="footnote-definition-label">5</sup>
<p><a href="https://hal.inria.fr/hal-01499974/">Polymorphic type inference and assignment</a>, Xavier Leroy and
Pierre Weis (1991)</p>
</div>
<div class="footnote-definition" id="wright"><sup class="footnote-definition-label">6</sup>
<p><a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5096&amp;rank=1">Simple Imperative Polymorphism</a>, Andrew Wright (1995)</p>
</div>
<h1><a class="header" href="#covariant-containers" id="covariant-containers">Covariant containers</a></h1>
<p><small><a href="glossary.html#subtyping">[subtyping]</a> <a href="glossary.html#variance">[variance]</a></small></p>
<p>If there is a subtyping between two types, say that every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">r</mi></mrow><annotation encoding="application/x-tex">\n{Car}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">C</span><span class="mord mathsf">a</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span></span></span></span></span> is
a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">V</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">e</mi></mrow><annotation encoding="application/x-tex">\n{Vehicle}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mord mathsf">e</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">c</span><span class="mord mathsf">l</span><span class="mord mathsf">e</span></span></span></span></span>, then it is natural to extend this subtyping to
container types, to say that a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">r</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[\n{Car}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">C</span><span class="mord mathsf">a</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span></span><span class="mclose">]</span></span></span></span> is also a
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">V</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">e</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[\n{Vehicle}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mord mathsf">e</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">c</span><span class="mord mathsf">l</span><span class="mord mathsf">e</span></span><span class="mclose">]</span></span></span></span>.</p>
<p>However, this is only sound for <em>immutable</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{List}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span></span></span></span> types. If
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{List}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span></span></span></span> is mutable, then a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">V</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">e</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[\n{Vehicle}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mord mathsf">e</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">c</span><span class="mord mathsf">l</span><span class="mord mathsf">e</span></span><span class="mclose">]</span></span></span></span> is something
into which I can insert a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">B</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">s</mi></mrow><annotation encoding="application/x-tex">\n{Bus}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">B</span><span class="mord mathsf">u</span><span class="mord mathsf">s</span></span></span></span></span>. If every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">r</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[\n{Car}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">C</span><span class="mord mathsf">a</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span></span><span class="mclose">]</span></span></span></span> is
automatically a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">V</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">e</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[\n{Vehicle}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mord mathsf">e</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">c</span><span class="mord mathsf">l</span><span class="mord mathsf">e</span></span><span class="mclose">]</span></span></span></span>, then you can end up with
buses in your list of cars.</p>
<p>This problem occurs with arrays in Java:</p>
<pre><code class="language-java">class Vehicle {}
class Car extends Vehicle {}
class Bus extends Vehicle {}
public class App {
  public static void main(String[] args) {
    Car[] c = { new Car() };
    Vehicle[] v = c;
    v[0] = new Bus(); // crashes with ArrayStoreException
  }
}
</code></pre>
<p>The solution is to keep track of <em>variance</em> (how subtyping of type
parameters affects subtyping of the whole type). There are two
approaches:</p>
<ul>
<li>
<p><strong>Use-site variance</strong> is used in Java (for types other than
arrays): a <code>List&lt;Car&gt;</code> can never be converted to a
<code>List&lt;Vehicle&gt;</code>, but can be converted to a <code>List&lt;? extends Vehicle&gt;</code>. The elements of a <code>List&lt;? extends Vehicle&gt;</code> are known
to be <code>Vehicle</code>s, but an arbitrary <code>Vehicle</code> cannot be inserted
into such a list. Each use of <code>List</code> specifies how the parameter
is allowed to vary.</p>
</li>
<li>
<p><strong>Declaration-site variance</strong> is used in Scala (although use-site
variance is also available). This means that the <code>List</code> type can
be defined as <code>List[+T]</code> if immutable, making every <code>List[Car]</code>
automatically a <code>List[Vehicle]</code>. However, if <code>List</code> is mutable, it
must be defined as <code>List[T]</code>, which disables these conversions.</p>
</li>
</ul>
<h1><a class="header" href="#incomplete-variance-checking" id="incomplete-variance-checking">Incomplete variance checking</a></h1>
<p><small><a href="glossary.html#subtyping">[subtyping]</a> <a href="glossary.html#variance">[variance]</a> <a href="glossary.html#typecase">[typecase]</a> <a href="glossary.html#recursive-types">[recursive-types]</a></small></p>
<p>With declaration-site variance (see <a href="covariant-containers.html">Covariant
containers</a>), it is possible to define a
class <code>C</code> with a covariant parameter <code>A</code>, so that <code>C[X]</code> is a subtype
of <code>C[Y]</code> whenever <code>X</code> is a subtype of <code>Y</code>. However, when typechecking
<code>C</code> it is important to verify that all uses of the parameter <code>A</code> are
actually compatible with covariance. Many soundness issues have arisen
from skipping such checks:</p>
<ul>
<li>
<p><strong>Private members</strong> may not need checking for variance, but this
is subtle. See <a href="privacy-violation.html">Privacy violation</a>.</p>
</li>
<li>
<p><strong>Constructor parameters</strong> do not normally need to be checked for
covariance, as they do not form part of an object's
interface. However, some language features can expose constructors
in the interface, in which case variance checking must be done. In
Scala<sup class="footnote-reference"><a href="#scala-param">1</a></sup>, constructors of inner classes are exposed by
an object and can refer to the objects' fields, while in
Hack<sup class="footnote-reference"><a href="#hack-construct">2</a></sup> constructors are accessible through the
(assumed covariant) <code>classname</code> type.</p>
<pre><code class="language-scala">// Counterexample by Martin Odersky
class C[+A] {
  private[this] var y: A = _
  def getY: A = y
  class Inner(x: A) {
    y = x
  }
}
 
object Test {
  def main(args: Array[String]) = {
    val x = new C[String]
    val y: C[Any] = x
    val i = new y.Inner(1)
    val s: String = x.getY
    println(s)
    // Exception in thread &quot;main&quot; java.lang.ClassCastException:
    // java.lang.Integer cannot be cast to java.lang.String
  }
}
</code></pre>
<pre><code class="language-hack">// Counterexample by Derek Lam (edited)
class Base {}
class Derived extends Base {
    public function __construct(public int $foo) {}
}
&lt;&lt;__ConsistentConstruct&gt;&gt;
abstract class A&lt;+T&gt; {
    abstract public function __construct(T $v);
}
class B extends A&lt;Derived&gt; {
    public function __construct(Derived $v){echo $v-&gt;foo;}
}
class C {
    public static function foo(): void {
        self::bar(B::class);
    }
    public static function bar(classname&lt;A&lt;Base&gt;&gt; $v): void {
        new $v(new Base()); // crashes
    }
}
</code></pre>
</li>
<li>
<p><strong>GADT parameters</strong> introduce equations between types when matched
on, making it unsound to mark them as either covariant or
contravariant. This issue showed up in early versions of OCaml and
in Scala<sup class="footnote-reference"><a href="#scala-gadt">3</a></sup>:</p>
<pre><code class="language-ocaml">(* Counterexample by Jeremy Yallop *)
let magic : 'a 'b. 'a -&gt; 'b =
  fun (type a) (type b) (x : a) -&gt;
    let bad_proof (type a) =
      (Refl : (&lt; m : a&gt;, &lt;m : a&gt;) eq :&gt; (&lt;m : a&gt;, &lt; &gt;) eq) in
    let downcast : type a. (a, &lt; &gt;) eq -&gt; &lt; &gt; -&gt; a =
      fun (type a) (Refl : (a, &lt; &gt;) eq) (s : &lt;&gt;) -&gt; (s :&gt; a) in
    (downcast bad_proof ((object method m = x end) :&gt; &lt; &gt;)) # m
</code></pre>
<pre><code class="language-scala">// Counterexample by Owen Healy
object Test extends App {
  sealed trait Node[+A]
  case class L[C,D](f: C =&gt; D) extends Node[C =&gt; D]

  def test[A,B](n: Node[A =&gt; B]): A =&gt; B = n match {
    case l: L[c,d] =&gt; l.f
  }

  println {
    test(new L[Int,Int](identity) with
      Node[Nothing]: Node[Int =&gt; String])(3): String
  }
}
</code></pre>
<p>The details of combining GADTs and declaration-site variance are
tricky. Giarusso<sup class="footnote-reference"><a href="#gadt-giarusso">4</a></sup> describes the problem in detail,
and Scherer and Rémy<sup class="footnote-reference"><a href="#gadt-scherer">5</a></sup> identify several cases where
they can be soundly combined.</p>
</li>
<li>
<p><strong>Self types</strong> allow a class to refer recursively to the type of
<code>this</code>, which may be a subtype of the class being
defined. However, if the class has type parameters, any use of a
self type must count as a use of those parameters. Failure to do
so led to a soundness issue in Hack<sup class="footnote-reference"><a href="#hack-self">6</a></sup>:</p>
<pre><code class="language-hack">// Counterexample by Derek Lam
class Base {}
class Derived extends Base {
    public function __construct(public int $derived_prop) {}
}
final class ImplCov&lt;+T&gt; {
    public function __construct(private T $v) {}
    public function put(this $v): void {
        $this-&gt;v = $v-&gt;v;
    }
    public function pull(): T {
        return $this-&gt;v;
    }
}
class Violate {
    public static function foo(ImplCov&lt;Derived&gt; $v): void {
        self::bar($v);
        echo $v-&gt;pull()-&gt;derived_prop;
        // Wait... Base doesn't have $derived_prop!
    }
    public static function bar(ImplCov&lt;Base&gt; $v): void {
        $v-&gt;put(new ImplCov(new Base()));
    }
}
// Violate::foo(new ImplCov(new Derived(42))); crashes
</code></pre>
</li>
<li>
<p><strong>Local types</strong> that are only used inside a single expression and
do not escape do not need variance checking, because they don't
form part of the interface. However, it's important to verify that
they don't escape! Otherwise, a soundness bug arises, as in
Scala<sup class="footnote-reference"><a href="#scala-local">7</a></sup>:</p>
<pre><code class="language-scala">// Counterexample by Paul Phillips
class A[+T] {
  val foo0 = {
    class AsVariantAsIWantToBe { def contains(x: T) = () }
    new AsVariantAsIWantToBe
  }
}

object Test {
  def main(args: Array[String]): Unit = {
    val xs: A[String] = new A[String]
    println(xs.foo0 contains &quot;abc&quot;)
    println((xs: A[Any]).foo0 contains 5) // crashes
  }
}
</code></pre>
</li>
<li>
<p><strong>Subclasses</strong> may introduce new methods which do not respect
covariance, producing an invariant subclass of a covariant
class. This is not by itself unsound, but can cause unsoundness if
the language also supports downcasting by pattern-matching,
allowing covariant use of the invariant derived class through the
covariant base class. This problem arose in Kotlin<sup class="footnote-reference"><a href="#kotlin-case">8</a></sup>
and in Scala<sup class="footnote-reference"><a href="#scala-case">9</a></sup><sup class="footnote-reference"><a href="#scala-case-2">10</a></sup>:</p>
<pre><code class="language-kotlin">// Counterexample by Ilya Gorbunov
// List is covariant, MutableList is an invariant subclass
private fun &lt;E&gt; List&lt;E&gt;.addAnything(element: E) {
    if (this is MutableList&lt;E&gt;) {
        this.add(element)
    }
}

arrayListOf(1, 2).addAnything(&quot;string&quot;)
</code></pre>
<pre><code class="language-scala">// Counterexample by Chung-Kil Hur
sealed abstract class MyADT[+A]
case object MyNone extends MyADT[Nothing]
case class MyFun[A](fun: A=&gt;A) extends MyADT[A]

def data : MyADT[Any] = MyFun((x:Int)=&gt;x+1)

val foo : Any =
  data match {
    case MyFun(f) =&gt; f(&quot;a&quot;)
    case _ =&gt; 0
  }
</code></pre>
</li>
</ul>
<div class="footnote-definition" id="scala-param"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/scala/bug/issues/9549">https://github.com/scala/bug/issues/9549</a> (2015)</p>
</div>
<div class="footnote-definition" id="hack-construct"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/facebook/hhvm/issues/7216">https://github.com/facebook/hhvm/issues/7216</a> (2016)</p>
</div>
<div class="footnote-definition" id="scala-gadt"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/scala/bug/issues/8563">https://github.com/scala/bug/issues/8563</a> (2014)</p>
</div>
<div class="footnote-definition" id="gadt-giarusso"><sup class="footnote-definition-label">4</sup>
<p><a href="http://lampwww.epfl.ch/%7Ehmiller/scala2013/resources/pdfs/paper5.pdf">Open GADTs and Declaration-site Variance: A Problem Statement</a>,
Paolo G. Giarrusso (2013)</p>
</div>
<div class="footnote-definition" id="gadt-scherer"><sup class="footnote-definition-label">5</sup>
<p><a href="https://arxiv.org/abs/1301.2903">GADTs meet subtyping</a> (ESOP '13)
Gabriel Scherer and Didier Rémy (2013)</p>
</div>
<div class="footnote-definition" id="hack-self"><sup class="footnote-definition-label">6</sup>
<p><a href="https://github.com/facebook/hhvm/issues/7254">https://github.com/facebook/hhvm/issues/7254</a> (2016)</p>
</div>
<div class="footnote-definition" id="scala-local"><sup class="footnote-definition-label">7</sup>
<p><a href="https://github.com/scala/bug/issues/5060">https://github.com/scala/bug/issues/5060</a> (2011)</p>
</div>
<div class="footnote-definition" id="kotlin-case"><sup class="footnote-definition-label">8</sup>
<p><a href="https://youtrack.jetbrains.com/issue/KT-7972">https://youtrack.jetbrains.com/issue/KT-7972</a> (2015)</p>
</div>
<div class="footnote-definition" id="scala-case"><sup class="footnote-definition-label">9</sup>
<p><a href="https://github.com/scala/bug/issues/8737#issuecomment-292432742">https://github.com/scala/bug/issues/8737#issuecomment-292432742</a> (2016)</p>
</div>
<div class="footnote-definition" id="scala-case-2"><sup class="footnote-definition-label">10</sup>
<p><a href="https://github.com/scala/bug/issues/6944">https://github.com/scala/bug/issues/6944</a> (2013)</p>
</div>
<h1><a class="header" href="#objects-under-construction" id="objects-under-construction">Objects under construction</a></h1>
<p><small><a href="glossary.html#mutation">[mutation]</a></small></p>
<p>There are two common styles for creating a new object or record. In
the first style, common in functional languages, the programmer
creates a new record by specifying the value of all of its fields in a
single expression:</p>
<pre><code class="language-ocaml">type t = { foo : int; bar : string }
let make () = { foo = 42; bar = &quot;hello&quot; }
</code></pre>
<p>In the second style, common in imperative and object-oriented
languages, the programmer creates a new record by first allocating a
blank record, and then filling its fields in one-by-one using
mutation:</p>
<pre><code class="language-c">struct t { int foo; const char* bar; };
struct t* x = malloc(sizeof(struct t));
x-&gt;foo = 42;
x-&gt;bar = &quot;hello&quot;;
</code></pre>
<pre><code class="language-java">class T {
  int foo;
  String bar;
  T () { this.foo = 42; this.bar = &quot;hello&quot;; }
}
</code></pre>
<p>In the first style, the record is fully constructed as soon as it is
available, and no intermediate states are visible. By contrast, the
second style allows intermediate states to be observed, which can have
confusing or unsound consequences.</p>
<p>For instance, Java allows fields to be marked <code>final</code>, which disallows
non-constructor assignments to the field, as in the following class:</p>
<pre><code class="language-java">class A {
  private final int x;
  public void printX() { System.out.println(x); }
  public A () { printX(); this.x = 42; printX(); }
}
</code></pre>
<p>A Java programmer might believe that the <code>printX</code> method will always
print the same value, but this is not the case as it may be invoked
while the object is still under construction.</p>
<p>This caused a soundness issue in Kotlin's non-null checking<sup class="footnote-reference"><a href="#kotlin">1</a></sup>, when a
non-nullable field was observed to be null during initialisation.</p>
<pre><code class="language-kotlin">// Counterexample by Joshua Rosen
class Foo {
    val nonNull: String

    init {
        this.crash()
        nonNull = &quot;Initialized&quot;
    }

    fun crash() {
        nonNull.startsWith(&quot;foo&quot;) // crashes
    }
}

fun main(args: Array&lt;String&gt;) {
    Foo()
}
</code></pre>
<p>In Java, it's additionally possible for <code>final</code> fields to never be
initialised, because a reference to an uninitialised object can leak
out via an exception:</p>
<pre><code class="language-java">class Ex extends RuntimeException {
    public Object o;
    public Ex(Object a) { this.o = a; }
    static int leak(Object x) { throw new Ex(x); }
}

class A {
    public final int leak = Ex.leak(this);
    public final int thing = Integer.parseInt(&quot;42&quot;);
}

public class Test {
    static A make() {
        try {
            return new A();
        } catch (Ex x) {
            return (A)x.o;
        }
    }
    public static void main(String []args){
       A a = make();
       // a is uninitialised: its 'thing' field is zero
       System.out.println(a.thing);
    }
}
</code></pre>
<div class="footnote-definition" id="kotlin"><sup class="footnote-definition-label">1</sup>
<p><a href="https://youtrack.jetbrains.com/issue/KT-10455">https://youtrack.jetbrains.com/issue/KT-10455</a> (2015)</p>
</div>
<h1><a class="header" href="#currys-paradox" id="currys-paradox">Curry's paradox</a></h1>
<p><small><a href="glossary.html#recursive-types">[recursive-types]</a> <a href="glossary.html#totality">[totality]</a></small></p>
<p>In the simply-typed lambda calculus (which has only function types and
a base type), infinite loops are impossible and all programs halt.
Surprisingly, this stops being true once recursive types are added,
even if no recursive functions or loops are present in the language.</p>
<p>In most languages, there are plenty of ways to write programs that do
not terminate, and finding one more is not a soundness issue. However,
in <em>total</em> languages (ones in which all programs halt), this does
present a soundness issue and the allowable forms of recursive types
must be restricted.</p>
<p>The recursive types in question are those that contain a function or
method which takes the same type as an argument, which can be used to
build a nonterminating computation as follows:</p>
<pre><code class="language-haskell">newtype Curry = Curry { r :: Curry -&gt; Int }

f c = r c c
loop = f (Curry f)
</code></pre>
<pre><code class="language-ocaml">type curry = { r : curry -&gt; int }

let f c = c.r c
let loop = f { r = f }
</code></pre>
<pre><code class="language-java">interface Curry {
  public int r(Curry x);
}
static int loop() {
  Curry c = new Curry() {
    public int r(Curry x) { return x.r(x); }
  };
  return c.r(c);
}
</code></pre>
<p>In logic, this is known as Curry's paradox.<sup class="footnote-reference"><a href="#curry1">1</a></sup> <sup class="footnote-reference"><a href="#curry2">2</a></sup> (This
has nothing to do with &quot;function currying&quot;, other than being named
after the same person.) Under the propositions-as-types viewpoint, it
causes inconsistency: by replacing <code>Int</code> with any proposition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>
(including <code>False</code>), the <code>loop</code> function above proves <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</p>
<p>To avoid this problem, languages that aim for logical consistency
(e.g. the proof assistants Coq and Agda) ban recursive types that take
themselves as arguments to functions or methods (so-called &quot;negative
recursion&quot;), avoiding Curry's paradox.</p>
<p>(In fact, due to a different issue, banning negative recursion is
often not enough, and recursive types must be restricted further to
&quot;strictly positive recursion&quot; to remain consistent. See <a href="strict-positivity.html">Positivity,
strict and otherwise</a>)</p>
<div class="footnote-definition" id="curry1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/Curry%27s_paradox">https://en.wikipedia.org/wiki/Curry%27s_paradox</a></p>
</div>
<div class="footnote-definition" id="curry2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://plato.stanford.edu/entries/curry-paradox/">https://plato.stanford.edu/entries/curry-paradox/</a></p>
</div>
<h1><a class="header" href="#eventually-nothing" id="eventually-nothing">Eventually, nothing</a></h1>
<p><small><a href="glossary.html#empty-types">[empty-types]</a></small></p>
<p>Many type systems allow an empty type, which has no values:</p>
<pre><code class="language-_rust">enum Empty {}
</code></pre>
<pre><code class="language-ocaml">type empty = |
</code></pre>
<pre><code class="language-haskell">data Empty
</code></pre>
<p>The eliminator for the empty type allows it to be turned into a value
of any other type, by handling each of the zero possible cases:</p>
<pre><code class="language-_rust">fn elim&lt;T&gt;(v : Empty) -&gt; T { match v {} }
</code></pre>
<pre><code class="language-ocaml">let elim (x : empty) = match x with _ -&gt; .
</code></pre>
<pre><code class="language-haskell">{-# LANGUAGE EmptyCase #-}
elim :: Empty -&gt; a
elim x = case x of {}
</code></pre>
<p>The <code>elim</code> function claims to be able to produce a valid value of an
arbitrary type, but will never need to actually do this since its
input cannot be supplied.</p>
<p>In non-total languages is it possible to write an expression
of type <code>empty</code>, by writing one that does not evaluate to a value but
instead fails or diverges:</p>
<pre><code class="language-_rust">fn bottom() -&gt; Empty { loop {} }
</code></pre>
<pre><code class="language-ocaml">let bottom : empty =
  let rec loop () = loop () in loop ()
</code></pre>
<pre><code class="language-haskell">bottom :: Empty
bottom = bottom
</code></pre>
<p>This interacts badly with an optimisation present in C compilers:
according to the C standard, compilers are allowed to assume that the
program contains no infinite loops without side-effects. (The point of
this odd assumption is to allow the compiler to delete a loop that
computes a value which is not used, without needing to first prove
that the loop terminates).</p>
<p>So, infinite loops may be deleted when compiling using a backend
designed for C and C++ (e.g. LLVM), allowing &quot;values&quot; of the empty
type to be constructed:</p>
<pre><code class="language-_rust">let s : &amp;str = elim(bottom());
println!(&quot;string: {}&quot;, s);
</code></pre>
<pre><code class="language-ocaml">(* The OCaml compiler does not delete empty loops, so
   computing bottom correctly hangs rather than crashing *)
print_endline (elim bottom)
</code></pre>
<pre><code class="language-haskell">-- GHC does not delete empty loops, so
-- this correctly hangs rather than crashing
putStrLn (elim bottom)
</code></pre>
<p>When optimisations are turned on, this program crashed in several versions of Rust<sup class="footnote-reference"><a href="#rustbug">1</a></sup>.</p>
<div class="footnote-definition" id="rustbug"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/rust-lang/rust/issues/28728">https://github.com/rust-lang/rust/issues/28728</a> (2015)</p>
</div>
<!-- FIXME: Make this segfault using Result<string, Empty> ?
  Cite C standard section?
  
--><h1><a class="header" href="#dubious-evidence" id="dubious-evidence">Dubious evidence</a></h1>
<p><small><a href="glossary.html#empty-types">[empty-types]</a> <a href="glossary.html#equality">[equality]</a></small></p>
<p>While the <code>Empty</code> type of the previous counterexample has no values at
all, there are types whose emptiness depends on their parameters. The
canonical example is the equality type, expressible as a GADT in
Haskell or OCaml or as an inductive family in Coq or Agda (among
others):</p>
<pre><code class="language-ocaml">type (_, _) eq =
  Refl : ('a, 'a) eq
</code></pre>
<pre><code class="language-haskell">data Eq a b where
  Refl :: Eq a a
</code></pre>
<pre><code class="language-coq">Inductive eq {S : Set} : S -&gt; S -&gt; Prop :=
  Refl a : eq a a.
</code></pre>
<pre><code class="language-agda">data Eq {S : Set} : S -&gt; S -&gt; Set where
  refl : (a : S) -&gt; Eq a a
</code></pre>
<p>The type <code>(a, b) eq</code> witnesses equality: it is nonempty if <code>a</code> and <code>b</code>
are the same type, and empty if they are distinct. Values of type <code>(a, b) eq</code> constitute evidence that <code>a</code> and <code>b</code> are in fact the same, and
can be used e.g. to turn an <code>a</code> into a <code>b</code>.</p>
<p>For an arbitrary type <code>a</code>, we have no way of making an <code>(int, a) eq</code>:
for all we know <code>a</code> might be <code>string</code>. The only way to construct a
value of the <code>eq</code> type is using <code>Refl</code>, which demands the parameters
be equal.</p>
<p>In a pure, total language, the existence of an expression of type <code>(a, b) eq</code> is enough to conclude <code>a</code> and <code>b</code> are equal. But in a less pure
language, where evaluation might fail or loop, the mere existence of
an expression with the right type is not evidence enough: we need to
actually run it, to see that it does in fact yield <code>Refl</code>. Several
type systems have had soundness bugs where evidence of this sort is
trusted without being fully evaluated:</p>
<ul>
<li>
<p><strong>Null evidence</strong></p>
<p>In languages with <code>null</code>, types like <code>eq</code> contain <code>null</code>, and
unlike <code>Refl</code>, <code>null</code> implies nothing about its type
parameters. So, before making use of any evidence we need to
verify that the evidence isn't <code>null</code>.</p>
<p>The lack of such verification caused a soundness issue in Java and
Scala<sup class="footnote-reference"><a href="#amintate">1</a></sup> (using a type that provides evidence for
subtyping, rather than equality):</p>
<pre><code class="language-java">// Counterexample by Nada Amin and Ross Tate
class Unsound {
  static class Constrain&lt;A, B extends A&gt; {}
  static class Bind&lt;A&gt; {
    &lt;B extends A&gt;
    A upcast(Constrain&lt;A,B&gt; constrain, B b) {
      return b;
    }
  }
  static &lt;T,U&gt; U coerce(T t) {
    Constrain&lt;U,? super T&gt; constrain = null;
    Bind&lt;U&gt; bind = new Bind&lt;U&gt;();
    return bind.upcast(constrain, t);
  }
  public static void main(String[] args) {
    String zero = Unsound.&lt;Integer,String&gt;coerce(0);
  }
}
</code></pre>
<pre><code class="language-scala">// Counterexample by Nada Amin and Ross Tate
object unsoundMini {
  trait A { type L &gt;: Any}
  def upcast(a: A, x: Any): a.L = x
  val p: A { type L &lt;: Nothing } = null
  def coerce(x: Any): Nothing = upcast(p, x)
  coerce(&quot;Uh oh!&quot;)
}
</code></pre>
</li>
<li>
<p><strong>Self-justifying evidence</strong></p>
<p>Evidence <code>p : (int, a) eq</code> can be used to construct more evidence
that <code>int</code> and <code>a</code> are equal, by seeing that <code>p</code> is <code>Refl</code>,
therefore learning that <code>int</code> and <code>a</code> are equal, and using this
information to justify <code>Refl : (int, a) eq</code>.</p>
<p>OCaml<sup class="footnote-reference"><a href="#ocamlbug">2</a></sup> had a soundness issue in which it allowed this sort of
reasoning in a recursive definition of <code>p</code>, allowing <code>p</code> to be
used as evidence for itself:</p>
<pre><code class="language-ocaml">(* Counterexample by Stephen Dolan *)
type (_,_) eq = Refl : ('a, 'a) eq
let cast (type a) (type b) (Refl : (a, b) eq) (x : a) = (x : b)

let is_int (type a) =
  let rec (p : (int, a) eq) = match p with Refl -&gt; Refl in
  p

let bang =
  (* segfaults *)
  print_string (cast (is_int : (int, string) eq) 42)
</code></pre>
</li>
<li>
<p><strong>Out-of-order evidence</strong></p>
<p>When nontermination is possible, it is important to ensure that
the order in which evidence is used matches the evaluation
order. Otherwise, it is possible to write an expression that does
not terminate, but make use of it before it runs. Such forward references
caused a soundness issue in Scala<sup class="footnote-reference"><a href="#scalafwd">3</a></sup>:</p>
<pre><code class="language-scala">// Counterexample by Paolo G. Giarrusso
new {
  val a: String = (((1: Any): b.A): Nothing): String
  def loop(): Nothing = loop()
  val b: { type A &gt;: Any &lt;: Nothing } = loop()
}
</code></pre>
</li>
<li>
<p><strong>Time-travelling evidence</strong></p>
<p><em>Staged metaprogramming</em> allows a program to manipulate program
fragments, gluing together an output program from quoted
fragments of code. However, it is unsound to allow evidence
computed in the future by the generated output program to justify
computations now. This caused a soundness bug in Scala's
implementation of staged metaprogramming<sup class="footnote-reference"><a href="#scalastage">4</a></sup> and in
BER MetaOCaml<sup class="footnote-reference"><a href="#metaocamlbug">5</a></sup>:</p>
<pre><code class="language-scala">// Counterexample by Lionel Parreaux
import scala.quoted.staging._

given Toolbox = Toolbox.make(getClass.getClassLoader)
trait T { type A &gt;: Any &lt;: Nothing }

withQuoteContext { '{ (x: T) =&gt; ${ 42: x.A } } }
// crashes with java.lang.ClassCastException
</code></pre>
<pre><code class="language-ocaml">(* Counterexample by Jeremy Yallop *)
type _ t = T : string t

let f : type a. a t option code -&gt; a -&gt; unit code =
  fun c x -&gt; .&lt; match .~c with
  | None -&gt; ()
  | Some T -&gt; .~(print_endline x; .&lt;()&gt;.) &gt;.

let _ = f .&lt; None &gt;. 0
</code></pre>
</li>
</ul>
<div class="footnote-definition" id="amintate"><sup class="footnote-definition-label">1</sup>
<p><a href="http://io.livecode.ch/learn/namin/unsound/scala">Java and Scala’s Type Systems are Unsound</a> (OOPSLA '16)
Nada Amin and Ross Tate (2016)</p>
</div>
<div class="footnote-definition" id="ocamlbug"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/7215">https://github.com/ocaml/ocaml/issues/7215</a> (2016)</p>
</div>
<div class="footnote-definition" id="scalafwd"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/lampepfl/dotty/issues/5854">https://github.com/lampepfl/dotty/issues/5854</a> (2019)</p>
</div>
<div class="footnote-definition" id="scalastage"><sup class="footnote-definition-label">4</sup>
<p><a href="https://github.com/lampepfl/dotty/issues/9353">https://github.com/lampepfl/dotty/issues/9353</a> (2020)</p>
</div>
<div class="footnote-definition" id="metaocamlbug"><sup class="footnote-definition-label">5</sup>
<p><a href="https://github.com/metaocaml/ber-metaocaml/blob/ber-n111/ber-metaocaml-111/test/tgadt.ml">https://github.com/metaocaml/ber-metaocaml/blob/ber-n111/ber-metaocaml-111/test/tgadt.ml</a> (2016)</p>
</div>
<h1><a class="header" href="#some-kinds-of-anything" id="some-kinds-of-anything">Some kinds of Anything</a></h1>
<p><small><a href="glossary.html#subtyping">[subtyping]</a> <a href="glossary.html#polymorphism">[polymorphism]</a></small></p>
<p>In type systems with polymorphism and subtyping, there are four
different meanings that the phrase &quot;any type&quot; could have:</p>
<ul>
<li>
<p><strong>Top type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">⊤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span></strong></p>
<p>The top type is a supertype of every type. Any value can be
turned into a value of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">⊤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span>, but given a value of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">⊤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span>
there's not much you can do with it.</p>
</li>
<li>
<p><strong>Bottom type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">⊥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span></strong></p>
<p>The bottom type is a subtype of every type. A value of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">⊥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span>
can be turned into a value of any type, but there's no way
to construct a value of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">⊥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span>. (If there is, the type system is
broken. See <a href="eventually-nothing.html">Eventually, nothing</a> for one
example).</p>
</li>
<li>
<p><strong>Universal type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mo>…</mo></mrow><annotation encoding="application/x-tex">∀α . ; \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></strong></p>
<p>A value of a universal type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>φ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∀α. φ(α)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span> can be used at type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">φ(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>,
for any type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. To construct one, the value must typecheck with
an unknown abstract type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</p>
</li>
<li>
<p><strong>Existential type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>α</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mo>…</mo></mrow><annotation encoding="application/x-tex">∃α . ; \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></strong></p>
<p>A value of an existential type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>φ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∃α. φ(α)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span> can be constructed from
a value of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">φ(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>, for any type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. To use one, the use must
typecheck with an unknown abstract type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</p>
</li>
</ul>
<p>There are a couple of relationships between these types:</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi><mo>=</mo><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">⊥ = ∀α. α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">⊥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span> is the type that can be used at any type, but cannot be constructed.</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi><mo>=</mo><mi mathvariant="normal">∃</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">⊤ = ∃α. α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">⊤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span> is the type that can be constructed from any type, but cannot be used.</p>
</li>
</ul>
<p>In some systems, these relationships extend to more complicated types
as well, for instance with a covariant type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> of immutable
lists with elements of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>:</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>α</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[⊥] = ∀α. \n{List}[α]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord">⊥</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">]</span></span></span></span></p>
<p>The elements of a single list <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> cannot simultaneously be of
every possible type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>. Such a list must be empty, which is the
same thing as being a list of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">⊥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span>.</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi mathvariant="normal">⊤</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∃</mi><mi>α</mi><mi mathvariant="normal">.</mi><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>α</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[⊤] = ∃α. \n{List}[α]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord">⊤</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">]</span></span></span></span></p>
<p>If a list contains elements of an unknown type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, then there is
nothing useful we can do with them. The situation is the same as
if we had a list of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">⊤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span>.</p>
</li>
</ul>
<p>The extent to which languages implement these rules varies. Sometimes<sup class="footnote-reference"><a href="#garrigue">1</a></sup>,
they are used to justify converting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">List[⊥]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">⊥</span><span class="mclose">]</span></span></span></span> to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>α</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">∀α.List[α]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">]</span></span></span></span>. Sometimes<sup class="footnote-reference"><a href="#mlsub">2</a></sup>, they are used to justify considering those
two as different spellings of the same type. Other times, they are not
used, but are definable in the language.</p>
<p>However, if implementing these rules it is crucial to keep track of
variance. Consider the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>α</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>α</mi><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∃α. (\n{List}[α] → \n{Int})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mopen">(</span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mclose">)</span></span></span></span>: this is a
function that accepts lists of some particular unknown type. It could
be, for instance, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">m</mi></mrow><annotation encoding="application/x-tex">\n{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">s</span><span class="mord mathsf">u</span><span class="mord mathsf">m</span></span></span></span></span> function of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">\n{List}[\n{Int}] →
\n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>.</p>
<p>It is unsound to treat this the same as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi mathvariant="normal">⊤</mi><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">\n{List}[⊤] → \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord">⊤</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>,
as that would allow us to pass a list of, say, strings to the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">m</mi></mrow><annotation encoding="application/x-tex">\n{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">s</span><span class="mord mathsf">u</span><span class="mord mathsf">m</span></span></span></span></span> function. In fact, since all of the occurrences of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> are
contravariant (that is, to the left of a single function arrow), this
type is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">\n{List}[⊥] → \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord">⊥</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>.</p>
<p>Scala supports subtyping and polymorphism, and several versions of the
language<sup class="footnote-reference"><a href="#scala1">3</a></sup><sup class="footnote-reference"><a href="#scala2">4</a></sup> had this soundness issue, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>φ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∃α. φ(α)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span> was converted to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi mathvariant="normal">⊤</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">φ(⊤)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord">⊤</span><span class="mclose">)</span></span></span></span> (spelled <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">y</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">φ(\n{Any})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord"><span class="mord mathsf">A</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span><span class="mclose">)</span></span></span></span> in Scala), without regard for the variance
of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">φ</span></span></span></span>.</p>
<pre><code class="language-scala">// Counterexample by Paul Chiusano
/* The 'coinductive' view of streams, represented as their unfold. */
trait Stream[+A]
case class Unfold[S,+A](s: S, f: S =&gt; Option[(A,S)]) extends Stream[A]

object Stream {
  def fromList[A](a: List[A]): Stream[A] = 
    Unfold(a, (l:List[A]) =&gt; l.headOption.map((_,l.tail)))
}

/* If I have a Stream[Int], and I match and obtain an Unfold(s, f),
   the type of (s,f) should be (S, S =&gt; Option[(A,S)]) forSome { type S }.
   But Scala just promotes everything to Any: */
val res0 = Stream.fromList(List(1,2,3,4))
val res1 = res0 match { case Unfold(s, f) =&gt; s }
// res1: Any = List(1, 2, 3, 4)

/* Notice that the type of s is Any.
   Likewise, the type of f is also wrong, it accepts an Any: */

val res2 = res0 match { case Unfold(s, f) =&gt; f }
// res2: Any =&gt; Option[(Int, Any)] = &lt;function1&gt;

/* Since f expects Any, we can give it a String and get a runtime error: */

res0 match { case Unfold(s, f) =&gt; f(&quot;a string!&quot;) } // crashes
</code></pre>
<div class="footnote-definition" id="garrigue"><sup class="footnote-definition-label">1</sup>
<p><a href="https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.pdf">Relaxing the Value Restriction</a>, Jacques Garrigue (2004)</p>
</div>
<div class="footnote-definition" id="mlsub"><sup class="footnote-definition-label">2</sup>
<p><a href="https://dl.acm.org/doi/abs/10.1145/3009837.3009882">Polymorphism, subtyping, and type inference in MLsub</a>, Stephen Dolan and Alan Mycroft (2017)</p>
</div>
<div class="footnote-definition" id="scala1"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/scala/bug/issues/5189">https://github.com/scala/bug/issues/5189</a> (2011)</p>
</div>
<div class="footnote-definition" id="scala2"><sup class="footnote-definition-label">4</sup>
<p><a href="https://github.com/scala/bug/issues/6680">https://github.com/scala/bug/issues/6680</a> (2012)</p>
</div>
<h1><a class="header" href="#any-single-thing" id="any-single-thing">Any (single) thing</a></h1>
<p><small><a href="glossary.html#polymorphism">[polymorphism]</a></small></p>
<p>When typechecking a language with polymorphism (generics), it is
usually up to the compiler to fill in the type parameters when a
polymorphic function / generic method is called.  For instance, given
polymorphic function <code>id</code> of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">∀α. α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, it can equally be
called as <code>id(5)</code> and <code>id(&quot;hello&quot;)</code>, and the compiler will work out
the correct value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> in both cases.</p>
<p>However, for any single call to <code>id</code> there is only one <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> to choose,
and the compiler must choose consistently. The expression <code>id(&quot;hello&quot;) + 5</code> is a type error, even though instantiating <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> to <code>string</code> and
<code>int</code> are both fine.</p>
<p>In practice, this means that whenever the compiler chooses a type
parameter it must record that choice and check compatibility with any
other use of the parameter. Early versions of Generic Java<sup class="footnote-reference"><a href="#java">1</a></sup> and
certain versions of Scala<sup class="footnote-reference"><a href="#scala">2</a></sup> and Kotlin<sup class="footnote-reference"><a href="#kotlin">3</a></sup> failed to do
this in all cases, leading to unsoundness.  The problem in each case
was incorrectly allowing conversions from a type with one arbitrary
parameter to a type with two arbitrary parameters, losing the
constraint that the two parameters must be chosen the same way.</p>
<pre><code class="language-java">// Counterexample by Alan Jeffrey
public class Problem {
    // This code compiles, but produces a ClassCastException when executed
    // even though there are no explicit casts in the program.
    
    public static void main (String [] args) {
        Integer x = new Integer (5);
        String y = castit (x);
        System.out.println (y);
    }

    static &lt;A,B&gt; A castit (B x) {
        // This method casts any type to any other type.
        // Oh dear.  This shouldn't type check, but does
        // because build () returns a type Ref&lt;*&gt;
        // which is a subtype of RWRef&lt;A,B&gt;.
        final RWRef&lt;A,B&gt; r = build ();
        r.set (x);
        return r.get ();
    }

    static &lt;A&gt; Ref&lt;A&gt; build () {
        return new Ref&lt;A&gt; ();
    }
}

interface RWRef&lt;A,B&gt; {
    public A get ();
    public void set (B x);
}

class Ref&lt;A&gt; implements RWRef &lt;A,A&gt; {
    A contents;
    public void set (A x) { contents = x; }
    public A get () { return contents; }
}
</code></pre>
<pre><code class="language-scala">// Counterexample by Stephen Compall
trait Magic {
  type S
  def init: S
  def step(s: S): String
}

case class Pair[A](left: A, right: A)

object Main extends App {
  type Aux[A] = Magic {type S = A}

  // I can't call this one from outerd,
  def outertp[A](p: Pair[Aux[A]]) =
    p.right.step(p.left.init)

  // but I can call this one.
  def outere(p: Pair[Aux[E]] forSome {type E}) =
    outertp(p)

  // This one means the left and the right may have *different* S.  I
  // shouldn't be able to call outere with p.
  def outerd(p: Pair[Magic]) =
    outere(p)

  def boom =
    outerd(Pair(new Magic {
                  type S = String
                  def init = &quot;hi&quot;
                  def step(s: S) = s.reverse
                },
                new Magic {
                  type S = Int
                  def init = 42
                  def step(s: S) = (s - 3).toString
                }))
  boom
}
</code></pre>
<pre><code class="language-kotlin">// Counterexample by Victor Petukhov
class A&lt;R1, K1&gt;(val r1: R1, var k1: K1)
class B&lt;R2, K2&gt;(val r2: R2, val k2: K2)
interface I
class Q1 : I
class Q2 : I {
    fun x() = &quot;&quot;
}
fun &lt;L, M&gt; foo(x: A&lt;L, M&gt;, y: B&lt;L, M&gt;) {
    x.k1 = y.k2
}
inline fun &lt;reified T : I&gt; bar(): B&lt;T, T&gt; {
    val w = T::class.constructors.first().call()
    return B(w, w)
}
fun main() {
    val a1 = A(Q1(), Q2())
    val a = a1 as A&lt;Q1, out Any?&gt;
    foo(a, bar()) // type mismatch in NI
    println(a1.k1.x())
}
</code></pre>
<div class="footnote-definition" id="java"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.seas.upenn.edu/%7Esweirich/types/archive/1999-2003/msg00849.html">Generic Java type inference is unsound</a> (TYPES mailing list), Alan Jeffrey (2001)</p>
</div>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/scala/bug/issues/9410">https://github.com/scala/bug/issues/9410</a> (2015)</p>
</div>
<div class="footnote-definition" id="kotlin"><sup class="footnote-definition-label">3</sup>
<p><a href="https://youtrack.jetbrains.com/issue/KT-35679">https://youtrack.jetbrains.com/issue/KT-35679</a> (2019)</p>
</div>
<h1><a class="header" href="#mutable-matching" id="mutable-matching">Mutable matching</a></h1>
<p><small><a href="glossary.html#mutation">[mutation]</a></small></p>
<p>Languages with sum types / algebraic datatypes generally include some
form of pattern-matching: a <code>match</code>/<code>case</code>/<code>switch</code> construct that can
inspect values.</p>
<p>The cases in a match statement often contain redundancy, and
compilers optimise these statements by coalescing repeated
subpatterns. For instance, consider this OCaml match:</p>
<pre><code class="language-ocaml">match x, y with
| 42, 0 -&gt; &quot;foo&quot;
| 42, n -&gt; &quot;bar&quot;
| n, _ -&gt; &quot;baz&quot;
</code></pre>
<p>The compiled code will first check whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>42</mn></mrow><annotation encoding="application/x-tex">x = 42</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">2</span></span></span></span>, and if so then
checks whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. The optimisation is that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y ≠ 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, the
code skips straight to the <code>&quot;bar&quot;</code> outcome, without rechecking whether
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>42</mn></mrow><annotation encoding="application/x-tex">x = 42</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">2</span></span></span></span>.</p>
<p>The assumption here is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> did not change between the first
pattern and the second. This assumption can be violated by the
presence of two features: first, the ability to pattern-match on
mutable fields, and second, the ability to run arbitrary code during
pattern matching. (The second feature usually shows up under the name
&quot;guards&quot;: additional arbitrary conditions that are checked before the
match succeeds).</p>
<p>If the language contains existential types (e.g. GADTs in OCaml,
abstract type members in Scala), then it is possible for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> to not
only change value but change type between two patterns, which leads to
unsoundness. This issue appeared in both OCaml<sup class="footnote-reference"><a href="#ocaml">1</a></sup> and
Scala<sup class="footnote-reference"><a href="#scala">2</a></sup>, which both support mutable matches, arbitrary
conditions in guards, and existential types. Rust<sup class="footnote-reference"><a href="#rust">3</a></sup> also had the
issue, with the unsoundness there resulting from disagreement about
lifetime rather than type.</p>
<pre><code class="language-ocaml">(* Counterexample by Stephen Dolan *)
type app = App : ('x -&gt; unit) option * 'x -&gt; app

let app1 = App (Some print_string, &quot;hello&quot;)
let app2 = App (None, 42)

type t = { 
  a : bool; 
  mutable b : app
}

let f = function
| { a = false } -&gt; assert false
| { a = true; b = App (None, _) } -&gt; assert false 
| { a = true; b = App (Some _, _) } as r 
    when (r.b &lt;- app2; false) -&gt; assert false
| { b = App (Some f, x) } -&gt;
   f x

let _ = f { a = true; b = app1 }
</code></pre>
<pre><code class="language-scala">// Counterexample by Iulian Dragos
abstract class Bomb {
    type T
    val x: T

    def size(that: T): Int
}

class StringBomb extends Bomb {
    type T = String
    val x = &quot;abc&quot;
    def size(that: String): Int = that.length
}

class IntBomb extends Bomb { 
    type T = Int
    val x = 10

    def size(that: Int) = x + that
}

case class Mean(var bomb: Bomb)

object Main extends App {
    def foo(x: Mean) = x match {
        case Mean(b) =&gt; 
            // b is assumed to be a stable identifier, 
            // but it can actually be mutated
			println(b.size({ mutate(); b.x }))
	}

	def mutate() {
	   	m.bomb = new IntBomb
	}

	val m = Mean(new StringBomb)
	foo(m)
}
</code></pre>
<pre><code class="language-_rust">// Counterexample by Ariel Ben-Yehuda
fn main() {
    match Some(&amp;4) {
        None =&gt; {},
        ref mut foo
            if {
                (|| { let bar = foo; bar.take() })();
                false
            } =&gt; {},
        Some(s) =&gt; println!(&quot;{}&quot;, *s)
    }
}
</code></pre>
<p>This can be fixed by disallowing pattern-matching on mutable fields,
or disallowing mutation during guards. (Either suffices). A trickier
solution chosen by both OCaml and Scala is to write the
pattern-match compiler extremely carefully so that it never loads a
mutable field twice, and so never assumes two possibly-distinct values
to be equal.</p>
<div class="footnote-definition" id="ocaml"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/7241">https://github.com/ocaml/ocaml/issues/7241</a> (2016)</p>
</div>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/scala/bug/issues/6070">https://github.com/scala/bug/issues/6070</a> (2012)</p>
</div>
<div class="footnote-definition" id="rust"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/rust-lang/rust/issues/27282">https://github.com/rust-lang/rust/issues/27282</a> (2015)</p>
</div>
<h1><a class="header" href="#runtime-type-misinformation" id="runtime-type-misinformation">Runtime type misinformation</a></h1>
<p><small><a href="glossary.html#typecase">[typecase]</a></small></p>
<p>The typing judgement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> is a static, syntactic judgement based on
the syntax of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>. Sometimes, it would be useful to have a
runtime counterpart, allowing expressions like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mtext>  </mtext><mo stretchy="false">?</mo><mtext>  </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">e ;?; A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mclose">?</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span></span></span></span> which
evaluate to <code>true</code> if at runtime the expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> evaluates to a
value of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>. This &quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">?</span></span></span></span>&quot; operator goes by various names, including
<code>typecase</code> and <code>instanceof</code>.</p>
<p>In any but the simplest type systems, this is fraught with
difficulties.  The trouble is that advanced type systems can make
finer distinctions than are visible at runtime, so the runtime type
check has incomplete information.</p>
<p>For example, using <code>newtype</code> in Haskell it is possible to define a
type <code>EscapedString</code> as a new type based on <code>String</code>:</p>
<pre><code class="language-haskell">newtype EscapedString = EscapedString String
</code></pre>
<p>Crucially, unlike type aliases (<code>type</code> in Haskell, or <code>typedef</code> in
C/C++) the two types <code>String</code> and <code>EscapedString</code> are distinct for
type checking purposes, causing a type error whenever one is used
where the other is expected and ensuring that a forgotten escaping or
unescaping causes a compile failure.</p>
<p>This extra checking has no runtime cost, because <code>newtype</code>s in Haskell
(and opaque types in ML, and similar features) introduce no extra
wrappers: the <code>String</code> and <code>EscapedString</code> have the same
representation.</p>
<p>This is fundamentally incompatible with typecase. The expression <code>e ? EscapedString</code> cannot be expected to return <code>true</code> on escaped strings
and <code>false</code> on unescaped ones, because at runtime there is no
distinction between them. The situation gets even worse with more
advanced type systems, since whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> has type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> may not even be
decidable at runtime.</p>
<p>It is possible to mix typecase with advanced type systems by limiting
the typecase operator to those types for which sufficient runtime
information is available, either by distinguishing static types from
dynamic tags (e.g. ML's <code>exn</code>, OCaml's open types), or by specifying
the subset of static types that have dynamically-checkable
representations (e.g. Haskell's <code>Typeable</code>, Scala's &quot;checkable types&quot;).</p>
<p>When this is not done carefully, unsoundness results, in which a
runtime tests identifies two types that are statically known to be
distinct. This problem has occurred in Scala<sup class="footnote-reference"><a href="#scala">1</a></sup> (where the types
checked in patterns did not always match the static ones) and some
cases remain in Dotty<sup class="footnote-reference"><a href="#dotty">2</a></sup>. The problem also occurs in Hack<sup class="footnote-reference"><a href="#hhvm">3</a></sup>
(where information about generics was erased at runtime, so typecase
returned <code>true</code> if asked whether a list of ints was a <code>List&lt;string&gt;</code>),
in Flow<sup class="footnote-reference"><a href="#flow">4</a></sup> (which also performs typecase on erased generics),
and in Kotlin<sup class="footnote-reference"><a href="#kotlin">5</a></sup> (where inner classes share runtime information,
even if they depend on generic parameters that may vary).</p>
<p>Java has an issue similar to those in Hack and Kotlin, where
<code>instanceof</code> checks ignore generic parameters, but avoids unsoundness
by limiting which classes can be used for comparison.</p>
<pre><code class="language-scala">// Counterexample by David R. MacIver
object Test extends Application {
    case class L();
    object N extends L();

    def empty(xs : L) : Unit = xs match {
        case x@N =&gt; println(x); println(x);
    }

    empty(L())
}
/*
The compiler inserts a cast of xs to N.type, which is unsound:
The pattern match will succeed for any L, because N == L().
*/
</code></pre>
<pre><code class="language-hack">// Counterexample by Andrew Kennedy
function mycast&lt;T&gt;(mixed $x, classname&lt;T&gt; $t) : T {
  if ($x instanceof $t) { return $x; }
  else throw new Exception(&quot;Type didn't match&quot;);
}
function expectListOfString(List&lt;string&gt; $x) { ... }

// If I write expectListOfString(mycast($y, List::class))
// but with $y having type List&lt;int&gt; then no exception will
// get thrown at runtime (because of generics erasure).
</code></pre>
<pre><code class="language-flow">// Counterexample by William Chargin
// @flow
class Box&lt;T&gt; {
  +field: T;
  constructor(x) {
    this.field = x;
  }
}

function asBox&lt;T&gt;(x: T | Box&lt;T&gt;): Box&lt;T&gt; {
  if (x instanceof Box) {
    // Here, `x` is refined to be `Box&lt;T&gt;`. This is unsound: `T` could
    // well be `Box&lt;U&gt;` for some other `U`. Example below.
    return x;
  } else {
    // whatever
    return new Box(x);
  }
}

const stringStringBox: Box&lt;Box&lt;string&gt;&gt; = asBox(new Box(&quot;wat&quot;));  // unsound!
stringStringBox.field.field.substr(0);  // runtime error
</code></pre>
<pre><code class="language-kotlin">// Counterexample by Vladimir Reshetnikov
class A&lt;T&gt;(var value: T) {
    fun replaceValue(x: Any) : Any {
        class C(var v: T)
        if(x is C) {
            value = x.v
            return x
        }

        return C(value)
    }
}

fun main(args: Array&lt;String&gt;) {
    val a = A(&quot;string&quot;)
    a.replaceValue(A(0).replaceValue(&quot;something not of type C&quot;))

    // a.value has type String, but now contains integer 0
    val s = a.value // crashes
}
</code></pre>
<pre><code class="language-java">// This function would do an unsound conversion from Integer to String
// because the cls.cast always passes: it's only checking List
static String bad(Class&lt;List&lt;String&gt;&gt; cls) {
    List&lt;Integer&gt; i = Arrays.asList(42);
    List&lt;String&gt; badList = cls.cast(i);
    String badString = badList.get(0);
    return badString;
}

// But Java provides no way to get a Class&lt;List&lt;String&gt;&gt;.
// (Arrays.asList(&quot;a&quot;).getClass() is a Class&lt;? extends List&gt;)
</code></pre>
<p>Runtime type tests are also tricky when the value being tested has a
union type: see <a href="polymorphic-union-refinement.html">Polymorphic union refinement</a>.</p>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/scala/bug/issues/1503">https://github.com/scala/bug/issues/1503</a> (2008)</p>
</div>
<div class="footnote-definition" id="dotty"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/lampepfl/dotty/issues/9359">https://github.com/lampepfl/dotty/issues/9359</a> (2020)</p>
</div>
<div class="footnote-definition" id="hhvm"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/facebook/hhvm/pull/7632">https://github.com/facebook/hhvm/pull/7632</a> (2017)</p>
</div>
<div class="footnote-definition" id="flow"><sup class="footnote-definition-label">4</sup>
<p><a href="https://github.com/facebook/flow/issues/6741">https://github.com/facebook/flow/issues/6741</a> (2018)</p>
</div>
<div class="footnote-definition" id="kotlin"><sup class="footnote-definition-label">5</sup>
<p><a href="https://youtrack.jetbrains.com/issue/KT-9584">https://youtrack.jetbrains.com/issue/KT-9584</a> (2015)</p>
</div>
<h1><a class="header" href="#overloading-and-polymorphism" id="overloading-and-polymorphism">Overloading and polymorphism</a></h1>
<p><small><a href="glossary.html#polymorphism">[polymorphism]</a> <a href="glossary.html#overloading">[overloading]</a></small></p>
<p>Polymorphism allows a single method to work with an arbitrary,
unknown type, while overloading allows one of multiple methods to be
selected by examining the types of the parameters. With overloading,
the parameter types become part of the name of the method. With
polymorphism, the parameter types might not be known.</p>
<p>The two features are in direct conflict, because the information that
overloading requires is unavailable in a polymorphic context. Attempts
to combine them are tricky, as this counterexample in Java<sup class="footnote-reference"><a href="#java">1</a></sup>
shows:</p>
<pre><code class="language-java">// Counterexample by Hiromasa Kido
class A{
       public int compareTo(Object o){ return 0; }
}
class B extends A implements Comparable&lt;B&gt;{
       public int compareTo(B b){ return 0; }
       public static void main(String[] argv){
               System.out.println(new B().compareTo(new Object()));
       }
}
</code></pre>
<pre><code class="language-scala">// Counterexample by Kota Mizushima
// (translation of Java counterexample, with the same effect)
class A {
  def compareTo(o: Any): Int = 0
}
class B extends A with Comparable[B] {
  def compareTo(b: B): Int = 0
}
object C {
  def main(args: Array[String]): Unit = {
    println(new B().compareTo(new Object()))
  }
}
</code></pre>
<p>On earlier versions of Java (and Scala<sup class="footnote-reference"><a href="#scala2">2</a></sup>), this program crashed
with a <code>ClassCastException</code>, despite containing no casts. The issue is
that in order to implement <code>B</code>'s <code>compareTo(B)</code>, the compiler inserts
a &quot;bridge method&quot; <code>compareTo(Object)</code> containing a cast to <code>B</code>. The
bridge method is necessary because the <code>compareTo</code> method is specified
by <code>Comparable</code>, and other users of the <code>Comparable</code> interface will
select the <code>compareTo(Object)</code> overload, as they do not necessarily
know about <code>B</code>.  However, this bridge method accidentally overrides
<code>A</code>'s <code>compareTo(Object)</code> method, and gets called from <code>main</code> instead,
and the cast fails.</p>
<p>In current Java, bridge methods still exist, but the program
above is rejected.</p>
<p>Scala<sup class="footnote-reference"><a href="#scala">3</a></sup> additionally has a related issue, also caused by an
interaction of overloading and polymorphism. Scala allows a mixture of
structural and nominal typing. An object can be given a structural
type that exposes only some of its capabilities, including exposing
only special cases of polymorphic methods:</p>
<pre><code class="language-scala">// Counterexample by Paul Phillips
object Test {
  class MyGraph[V &lt;: Any] {
    def addVertex(v: V): Boolean = true
  }

  type DuckGraph = {
    def addVertex(vertex: Int): Boolean
  }
  
  def fail(graph: DuckGraph) = graph addVertex 1

  def main(args: Array[String]): Unit = {
    fail(new MyGraph[Int])
  }
}
</code></pre>
<p>However, overloading causes this program to fail, by attempting to find a
nonexistent <code>addVertex(Int)</code> method, even though the underlying polymorphic method has
signature <code>addVertex(Object)</code>.</p>
<div class="footnote-definition" id="java"><sup class="footnote-definition-label">1</sup>
<p><a href="http://lists.seas.upenn.edu/pipermail/types-list/2006/001091.html">Java generics unsoundness?</a>
(TYPES mailing list), Eijiro Sumii (2006)</p>
</div>
<div class="footnote-definition" id="scala2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/scala/bug/issues/9912">https://github.com/scala/bug/issues/9912</a> (2016)</p>
</div>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/scala/bug/issues/2672">https://github.com/scala/bug/issues/2672</a> (2009)</p>
</div>
<h1><a class="header" href="#distinctness-i-injectivity" id="distinctness-i-injectivity">Distinctness I: Injectivity</a></h1>
<p><small><a href="glossary.html#injectivity">[injectivity]</a></small></p>
<p>Type checkers spend much of their time verifying that pairs of types
are equal, or at least compatible, checking for instance that the type
of the argument to a function matches the type it expects.</p>
<p>Occasionally, they need to do the opposite, and verify that two types
are distinct. One common case of this is allowing the programmer
to omit those cases of a pattern match which are impossible
because they would imply that two distinct types are equal. For
instance, given a value which is either a string, or evidence that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow></mrow><annotation encoding="application/x-tex">\n{Int} = \n{String}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span>, then matching on this value need only handle
the first case as the second is impossible.</p>
<pre><code class="language-ocaml">type (_,_) eq = Refl : ('a, 'a) eq
type ('a, 'b) either = Left of 'a | Right of 'b

let f (x : (string, (int,string) eq) either) =
  match x with
  | Left s -&gt; s
  (* no case for Right, and yet the match is exhaustive *)
</code></pre>
<pre><code class="language-agda">-- Agda can reason about distinctness of more than just types
open import Agda.Builtin.String
data Eq (a : String) : String -&gt; Set where
  Refl : Eq a a

data Sum (A B : Set) : Set where
  Left : A -&gt; Sum A B
  Right : B -&gt; Sum A B

f : Sum String (Eq &quot;foo&quot; &quot;bar&quot;) -&gt; String
f (Left s) = s
f (Right ()) -- &quot;()&quot; is the absurd pattern
</code></pre>
<p>Of course, this is unsound if the type system is wrong about two types
being distinct. One common way that this can occur is when the type
system assumes that all type constructors are <em>injective</em>.</p>
<p>Injectivity of a type constructor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> means that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[A] = F[B]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span></span></span></span>,
then the types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> are equal. Most common type constructors
(<code>List</code>, <code>Array</code> and so on) are in fact injective, so this is a
natural property to expect. However, if it is possible to define a
type constructor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">F[A] = \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>, then injectivity fails. This
issue occurred in Dotty<sup class="footnote-reference"><a href="#dotty">1</a></sup>, a research Scala compiler, as well as in Agda<sup class="footnote-reference"><a href="#agda">2</a></sup>
(with the <code>injective-type-constructors</code> option). Curiously, Haskell
makes the same assumption, but without unsoundness.</p>
<pre><code class="language-scala">// Counterexample by Aleksander Boruch-Gruszecki
object Test {
  sealed trait EQ[A, B]
  final case class Refl[T]() extends EQ[T, T]

  def absurd[F[_], X, Y](eq: EQ[F[X], F[Y]], x: X): Y = eq match {
    case Refl() =&gt; x
  }

  var ex: Exception = _
  try {
    type Unsoundness[X] = Int
    val s: String = absurd[Unsoundness, Int, String](Refl(), 0)
  } catch {
    case e: ClassCastException =&gt; ex = e
  }

  def main(args: Array[String]) =
    assert(ex != null)
}
</code></pre>
<pre><code class="language-agda">-- Counterexample by Andreas Abel
{-# OPTIONS --injective-type-constructors #-}

open import Common.Prelude
open import Common.Equality

abstract
  f : Bool → Bool
  f x = true

  same : f true ≡ f false
  same = refl

not-same : f true ≡ f false → ⊥
not-same ()

absurd : ⊥
absurd = not-same same
</code></pre>
<pre><code class="language-haskell">data Equ a b where
  Refl : Equ a a

-- not in fact unsound! see below
everythingIsInjective :: Equ (f a) (f b) -&gt; Equ a b
everythingIsInjective Refl = Refl
</code></pre>
<p>The reason that it is sound for Haskell to assume an arbitrary type
constructor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is injective is that it draws a distinction between
type constructors and type-level functions. The following two
declarations are distinct:</p>
<pre><code class="language-haskell">type family Foo :: * -&gt; *
type family Bar a :: *
</code></pre>
<p>Here, <code>Foo</code> is defined as a type constructor, something of kind <code>* -&gt; *</code>. This kind only contains injective type constructors (like lists,
etc.).
By contrast, <code>Bar</code> is defined as a type-level function. <code>Bar</code> is not
necessarily injective, as one can define:</p>
<pre><code class="language-haskell">type instance Bar a = Int
</code></pre>
<p>However, <code>Bar</code> is not of kind <code>* -&gt; *</code>, and cannot be passed as the
<code>f</code> parameter to <code>everythingIsInjective</code>:</p>
<pre><code class="language-haskell">eqFoo :: Equ (Foo a) (Foo b) -&gt; Equ a b
eqFoo = everythingIsInjective -- works

eqBar :: Equ (Bar a) (Bar b) -&gt; Equ a b
eqBar = everythingIsInjective -- error
</code></pre>
<p>In fact, in Haskell there is currently no way to quantify over things
like <code>Bar</code>: Haskell's higher-kinded types only allow passing around
injective type constructors. A recent paper by Kiss et al.<sup class="footnote-reference"><a href="#haskell">3</a></sup> proposes adding
parameterisation by type functions to Haskell, by adding a new kind <code>* =&gt; *</code> which does not carry injectiveness assumptions.</p>
<div class="footnote-definition" id="dotty"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/lampepfl/dotty/issues/5658">https://github.com/lampepfl/dotty/issues/5658</a> (2018)</p>
</div>
<div class="footnote-definition" id="agda"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/agda/agda/issues/2250">https://github.com/agda/agda/issues/2250</a> (2016)</p>
</div>
<div class="footnote-definition" id="haskell"><sup class="footnote-definition-label">3</sup>
<p><a href="https://www.microsoft.com/en-us/research/publication/higher-order-type-level-programming-in-haskell/">Higher-order Type-level Programming in
Haskell</a>
(ICFP '19), Csongor Kiss, Susan Eisenbach, Tony Field, Simon Peyton
Jones (2019)</p>
</div>
<h1><a class="header" href="#distinctness-ii-recursion" id="distinctness-ii-recursion">Distinctness II: Recursion</a></h1>
<p><small><a href="glossary.html#recursive-types">[recursive-types]</a></small></p>
<p>(This is the same sort of problem as <a href="distinctness-injectivity.html">the previous
counterexample</a>, so read that first for
context.)</p>
<p>When checking distinctness of two types that contain type variables,
one approach is to attempt to unify them and see whether there is a
common unifier. (Be careful! It is easy to <a href="distinctness-injectivity.html">assume
injectivity</a> this way).</p>
<p>Unification can fail because of the <em>occurs check</em>, under which a type
variable cannot be unified with a type mentioning the same
variable. For instance, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> fail to unify because of this
check.</p>
<p>So, if using unification to check distinctness, it is natural to
believe that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> are distinct, regardless of what <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> is.
However, this is only sound if there are no infinite or recursive
types in the language: if a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> could be constructed equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T
→ T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> would no longer be distinct.</p>
<p>Even when they are not directly supported, it is easy for infinite or
recursive types to sneak into the language, which creates a soundness
issue in languages checking distinctness by unification. This occurred
in both Haskell<sup class="footnote-reference"><a href="#haskell">1</a></sup> and OCaml<sup class="footnote-reference"><a href="#ocaml1">2</a></sup>, for the same reason: if the definition of a
recursive type is split across module boundaries (multiple files with
type families in Haskell, or a single recursive module in OCaml), then
the typechecker will never see the construction of the whole recursive
type and so cannot reject it. This allows a counterexample to
distinctness, which can be exploited either via a Haskell type family
or and OCaml GADT match.</p>
<pre><code class="language-haskell">-- Counterexample by Akio Takano
-- Base.hs
{-# LANGUAGE TypeFamilies #-}
module Base where

-- This program demonstrates how Int can be cast to (IO String)
-- using GHC 7.6.3.
type family F a
type instance F (a -&gt; a) = Int
type instance F (a -&gt; a -&gt; a) = IO String

-- Given this type family F, it is sufficient to prove
-- (LA -&gt; LA) ~ (LA -&gt; LA -&gt; LA)
-- for some LA. This needs to be done in such a way that
-- GHC does not notice LA is an infinite type, otherwise
-- it will complain.
--
-- This can be done by using 2 auxiliary modules, each of which
-- provides a fragment of the proof using different partial knowledge
-- about the definition of LA.
--
-- LA -&gt; LA
-- = {LA~LB-&gt;LB} -- only Int_T.hs knows this
-- LA -&gt; LB -&gt; LB
-- = {LA~LB}     -- only T_IOString.hs knows this
-- LA -&gt; LA -&gt; LA
type family LA
type family LB
data T = T (F (LA -&gt; LB -&gt; LB))

-- Int_T.hs
{-# LANGUAGE TypeFamilies, UndecidableInstances #-}
module Int_T where
import Base
type instance LA = LB -&gt; LB

int_t0 :: Int -&gt; T
int_t0 = T

-- T_IOString.hs
{-# LANGUAGE TypeFamilies, UndecidableInstances #-}
module T_IOString where
import Base
type instance LB = LA

t_ioString :: T -&gt; IO String
t_ioString (T x) = x

-- Main.hs
import Int_T
import T_IOString

main :: IO ()
main = t_ioString (int_t0 100) &gt;&gt;= print
</code></pre>
<pre><code class="language-ocaml">(* Counterexample by Stephen Dolan *)
type (_, _) eqp = Y : ('a, 'a) eqp | N : string -&gt; ('a, 'b) eqp
let f : ('a list, 'a) eqp -&gt; unit = function N s -&gt; print_string s

(* Using recursive modules, we can construct a type t = t list,
   even without -rectypes: *)

module rec A : sig
  type t = B.t list
end = struct
  type t = B.t list
end and B : sig
  type t
  val eq : (B.t list, t) eqp
end = struct
  type t = A.t
  let eq = Y
end

(* The expression f B.eq segfaults *)
</code></pre>
<div class="footnote-definition" id="haskell"><sup class="footnote-definition-label">1</sup>
<p><a href="https://ghc.haskell.org/trac/ghc/ticket/8162">https://ghc.haskell.org/trac/ghc/ticket/8162</a> (2013)</p>
</div>
<div class="footnote-definition" id="ocaml1"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/6993">https://github.com/ocaml/ocaml/issues/6993</a> (2015)</p>
</div>
<!-- FIXME:
 point not well made:
  distinction between "not provably equal" and "provably distinct"
    negation-as-failure doesn't cut it under abstraction!

 should this include "Awkward Case 3" from "Injective Type Families for Haskell"?
--><h1><a class="header" href="#distinctness-iii-options" id="distinctness-iii-options">Distinctness III: Options</a></h1>
<p>Many compilers for typed languages accept options which affect type
checking, and to ensure soundness, some care must be taken if mixing
files typechecked with different options.</p>
<p>Options which enable or disable new type system features are
relatively unproblematic, but trouble can occur if options affect
existing types: if two types are considered equal with the option but
are provably distinct without it, then it is unsound to combine two
files compiled with and without the option.</p>
<p>This has caused a soundness bug in Agda<sup class="footnote-reference"><a href="#agda">1</a></sup>, by mixing code
compiled with the <code>--cubical</code> option (which permits multiple proofs of
equality) and the <code>--with-K</code> option (which assumes equalities have
unique proofs). Similar bugs arose several times in OCaml, based on
various options that affect type equality: <code>--rectypes</code>, which permits
recursive types<sup class="footnote-reference"><a href="#ocamlrec">2</a></sup>, <code>--safe-string</code>, which makes the immutable <code>string</code>
and mutable <code>bytes</code> type distinct<sup class="footnote-reference"><a href="#ocamlstr">3</a></sup>, and <code>--nolabels</code>, which coarsens
equality of function types with named parameters<sup class="footnote-reference"><a href="#ocamllbl">4</a></sup>.</p>
<pre><code class="language-ocaml">(* Counterexample by Gabriel Scherer and Benoît Vaugon *)
(* blah.ml, compiled without -rectypes *)
type ('a, 'b, 'c) eqtest =
  | Refl : ('a, 'a, float) eqtest
  | Diff : ('a, 'b, int) eqtest

let test : type a b . (unit -&gt; a, a, b) eqtest -&gt; b = function
  | Diff -&gt; 42

(* bluh.ml, compiled with -rectypes *)
let () =
  print_float Blah.(test (Refl : (unit -&gt; 'a as 'a, 'a, _) eqtest))
</code></pre>
<p>These sorts of issues are conspicuously absent from GHC Haskell, which
supports an unusually large number of options that affect
typechecking. A reason for this is that internally, GHC compiles
Haskell with any set of extensions to the same typed intermediate
language, Core. Since the Core language is unaffected by options,
incompatibilities between options would cause one of them to generate
ill-typed Core, which can be detected locally.</p>
<div class="footnote-definition" id="agda"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/agda/agda/issues/2487#issuecomment-444498567">https://github.com/agda/agda/issues/2487#issuecomment-444498567</a> (2017)</p>
</div>
<div class="footnote-definition" id="ocamlrec"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/6405">https://github.com/ocaml/ocaml/issues/6405</a> (2014)</p>
</div>
<div class="footnote-definition" id="ocamlstr"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/7113">https://github.com/ocaml/ocaml/issues/7113</a> (2016)</p>
</div>
<div class="footnote-definition" id="ocamllbl"><sup class="footnote-definition-label">4</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/7432">https://github.com/ocaml/ocaml/issues/7432</a> (2016)</p>
</div>
<h1><a class="header" href="#subtyping-vs-inheritance" id="subtyping-vs-inheritance">Subtyping vs. inheritance</a></h1>
<p><small><a href="glossary.html#subtyping">[subtyping]</a></small></p>
<p>In an object-oriented language, after writing a class <code>A</code> there are
two different ways we might want to extend it:</p>
<ul>
<li>
<p><strong>Subtyping</strong> means writing a class <code>B</code> which conforms to <code>A</code>'s
interface, as well as possibly adding some new methods of its
own. Per Liskov's substitution principle<sup class="footnote-reference"><a href="#liskov">1</a></sup>, in any
context where an <code>A</code> is expected we can supply a <code>B</code> instead.</p>
</li>
<li>
<p><strong>Inheritance</strong> means writing a class <code>B</code> that specialises <code>A</code> to
a particular use, by reusing some of its behaviour and perhaps
overriding parts.</p>
</li>
</ul>
<p>The two are similar: if the class <code>B</code> reuses all of <code>A</code>'s
functionality and adds some new methods of its own, then <code>B</code> will both
inherit from and be a subtype of <code>A</code>.</p>
<p>However, they are not the same. Suppose <code>B</code> inherits most of its
behaviour from <code>A</code>, but overrides a single method <code>m</code>. If <code>B</code> is a
specialised version of <code>A</code>, its <code>m</code> might require a specialised input,
accepting only a specialised version of <code>A.m</code>'s input. On the other
hand, if <code>B</code> is a subtype of <code>A</code>, then in order to conform <code>A</code>'s
interface its <code>m</code> must accept <em>all</em> inputs that <code>A.m</code> accepts,
requiring the input of <code>B.m</code> to be a <em>supertype</em> of that of <code>A.m</code>.</p>
<p>Many object-oriented languages conflate inheritance and subtyping as
<em>subclassing</em>. Three representative examples are C#, Eiffel and
TypeScript, which differ in how overridden methods in a subclass are
typechecked.</p>
<p>C# insists that subclasses' methods accept exactly the same types
the overridden method accepts, which is sound but makes some uses of
subtyping and specialisation awkward. Eiffel prefers specialisation,
insisting that subclasses' methods accept subtypes of what the
overridden method accepts, which is unsound<sup class="footnote-reference"><a href="#cook">2</a></sup>. TypeScript is ambivalent,
requiring only that subclasses' methods accept either a supertype <em>or</em> a
subtype of what the overridden method accepts, which is also unsound.</p>
<p>The soundness issue is the same one in both TypeScript and Eiffel:
Suppose a method <code>A.m</code> may be overridden by <code>B.m</code>, where <code>B.m</code> accepts
only a subtype of the original type. Since <code>B</code> is deemed a subtype of
<code>A</code>, a <code>B</code> can be used as though it were an <code>A</code>, and by invoking its
<code>B.m</code> method through <code>A</code> an argument which is not of the subtype it
expects can be supplied.</p>
<pre><code class="language-typescript">interface Base {
    name: string;
}
interface Sub {
    name: string;
    doStuff: () =&gt; number;
}

class A {
    go(_ : Base) {}
}
class B extends A {
    go(x : Sub) { x.doStuff(); }
}

let x : Base = { name: &quot;x&quot; };
let b = new B();
let a : A = b;
a.go(x); // crashes
</code></pre>
<pre><code class="language-eiffel">-- Counterexample by W. R. Cook
class Base feature
  base (n : Integer) : Integer
    do Result := n * 2 end;
end
---
class Extra inherit Base feature
  extra (n : Integer) : Integer
    do Result := n * n end;
end
---
class P2 feature
  get (arg : Base) : Integer
    do Result := arg.base(1) end
end
---
class C2 inherit P2 redefine get end feature
  get (arg : Extra) : Integer
    do Result := arg.extra(2) end
end
---
  local
    a : Base
    v : P2
    b : C2
    i : Integer
  do
    create a;
    create b;
    v := b;
    i := v.get(a) -- crashes!
  end
</code></pre>
<pre><code class="language-ocaml">class type base = object
  method name : string 
end
class type sub = object
  method name : string
  method do_stuff : int
end

class a = object
  method go (_ : base) = ()
end

class b = object (self : &lt; go : sub -&gt; int; .. &gt;)
  (* does not compile *)
  inherit a
  method! go (x : sub) = x#doStuff
end
</code></pre>
<pre><code class="language-csharp">class A {
  public void go(Object arg) {}
}
class B : A {
  // does not compile
  public override void go(String arg) {}
}
</code></pre>
<p>Since version 2.6, TypeScript supports the <code>strictFunctionTypes</code>
option<sup class="footnote-reference"><a href="#typescriptStrict">3</a></sup>, which uses a stricter subtyping check in
some cases. However, the counterexample above is still accepted with
<code>strictFunctionTypes</code>.</p>
<p>Theoretically, Eiffel recovers soundness by the &quot;system validity
check&quot;, a whole-program dataflow analysis designed to detect
situations like Cook's counterexample (which the Eiffel community
terms &quot;catcalls&quot;, for &quot;Changed Availability or Type&quot;). However, this
check is quite tricky, and it appears that no Eiffel compilers have
ever actually implemented it<sup class="footnote-reference"><a href="#cats">4</a></sup>.</p>
<p>The same issue can crop up with <em>class methods</em>, which are methods
that are associated with a class rather than with an instance of that
class. Languages with class methods allow classes to be passed around
as values, dispatching method calls to the appropriate class as
determined at runtime.</p>
<p>When class methods can be overridden in a subclass, this raises the
same subtyping vs. inheritance issue: may the subclass specialise its
argument type, or must it accept a supertype? A soundness issue along
these lines (analogous to the one above) arose in Swift<sup class="footnote-reference"><a href="#swift">5</a></sup>:</p>
<pre><code class="language-swift">// Counterexample by Ben Pious
class C&lt;T&gt; {
    
    let t: T
    
    init(t: T) {
        self.t = t
        type(of: self).f()(self)
    }
    
    class func f&lt;U&gt;() -&gt; (U) -&gt; () where U: C  {
        return { (u: U) in
            print(u.t)
        }
    }
}

class E {
    let g = &quot;Expected to Print&quot;
}

class D: C&lt;E&gt; {
    override class func f&lt;U&gt;() -&gt; (U) -&gt; () where U: E {
        return { (u: E) in
            print(u.g)
        }
    }
}

let d = D(t: E()) // prints random garbage
</code></pre>
<div class="footnote-definition" id="liskov"><sup class="footnote-definition-label">1</sup>
<p><a href="https://dl.acm.org/doi/10.1145/197320.197383">A behavioral notion of subtyping</a>,
Barbara Liskov and Jeannette Wing (1994)</p>
</div>
<div class="footnote-definition" id="cook"><sup class="footnote-definition-label">2</sup>
<p><a href="https://academic.oup.com/comjnl/article/32/4/305/377555">A Proposal for Making Eiffel Type-safe</a>, W. R. Cook (1989)</p>
</div>
<div class="footnote-definition" id="typescriptStrict"><sup class="footnote-definition-label">3</sup>
<p><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html</a> (2017)</p>
</div>
<div class="footnote-definition" id="cats"><sup class="footnote-definition-label">4</sup>
<p><a href="http://se.inf.ethz.ch/old/projects/markus_keller/diplom">Catching CATs</a>, Markus Keller (2003)</p>
</div>
<div class="footnote-definition" id="swift"><sup class="footnote-definition-label">5</sup>
<p><a href="https://bugs.swift.org/browse/SR-7573">https://bugs.swift.org/browse/SR-7573</a> (2018)</p>
</div>
<h1><a class="header" href="#selfishness" id="selfishness">Selfishness</a></h1>
<p><small><a href="glossary.html#subtyping">[subtyping]</a></small></p>
<p>Most statically typed object-oriented languages allow a group of
related methods to be specified together as an <em>interface</em> (or
&quot;trait&quot;, &quot;protocol&quot;, etc.). <em>Self types</em> are a feature that allows the
types in such an interface to refer to the type implementing that
interface.</p>
<p>Using self types as method arguments allows precise typechecking of
<em>binary methods</em><sup class="footnote-reference"><a href="#binary">1</a></sup> such as <code>equals</code>, where <code>x.equals(y)</code>
requires a <code>y</code> of the same type as <code>x</code>. The lack of such types in
e.g. Java means that the <code>Object.equals</code> method must usually include a
cast that can fail at runtime, as its type allows any other object to
be passed.</p>
<p>Using self types as returns allows precise typechecking of methods
that return <code>this</code>, or methods that copy the receiving object.</p>
<p>However, the presence of self types breaks some properties of the type
system, and unsoundness arises if other parts of the system rely on
them.</p>
<ul>
<li>
<p>Argument self types break the property that, if a class <code>C</code> has a
subclass <code>D</code> and both implement an interface <code>P</code>, then a <code>D</code> can
be used anywhere a <code>C</code> is expected. The issue is that <code>P</code> may
include a method that accepts a self type, and this method in <code>D</code>
works on a narrower class of inputs than the corresponding method
in <code>C</code>. (See <a href="subtyping-vs-inheritance.html">Subtyping vs. inheritance</a>)</p>
<pre><code class="language-ocaml">class c (name : string) =
  object (self : 'self)
    method name = name
    method equals (x : 'self) =
      (name = x#name)
  end

class d (name : string) (size : int) =
  object
    inherit c name as super
    method size = size
    method equals (x : 'self) =
      (super#equals x &amp;&amp; size = x#size)
  end

let sub (x : d) = (x :&gt; c)
(* OCaml correctly rejects this coercion:
   despite inheriting from it, d is not a subtype of c *)
</code></pre>
</li>
<li>
<p>Returned self types break the property that, if a class <code>C</code>
implements an interface <code>P</code>, and subclass <code>D</code> inherits all of its
behaviour from <code>C</code>, then <code>D</code> also implements <code>P</code>.</p>
<p>The issue is that <code>P</code> may include a method that returns
<code>Self</code>, which <code>C</code> implements by returning a new <code>C</code>. When this
method is inherited by <code>D</code> it still returns <code>C</code>, even though <code>P</code>
now requires that it return <code>D</code>. This led to a soundness issue in
Swift<sup class="footnote-reference"><a href="#swift">2</a></sup>, and a related issue in Rust<sup class="footnote-reference"><a href="#rust">3</a></sup>:</p>
<pre><code class="language-swift">// Counterexample by Hamish Knight
protocol P {
  associatedtype X where X == Self
  func foo() -&gt; X
}

class C : P {
  typealias X = C
  func foo() -&gt; X {
    return C()
  }
}
class D : C {
    var name = &quot;D&quot;
}

func foo&lt;T : P&gt;(_ x: inout T) {
  x = x.foo()
}

var d = D()
foo(&amp;d)
print(d.name) // crashes
</code></pre>
<pre><code class="language-_rust">// Counterexample by Niko Matsakis
trait Make {
    fn make() -&gt; Self;
}

impl Make for *const uint {
    fn make() -&gt; *const uint {
        ptr::null()
    }
}

fn maker&lt;M:Make&gt;() -&gt; M {
    Make::make()
}

fn main() {
    let a: *uint = maker::&lt;*uint&gt;();
    // we have &quot;produced&quot; a *uint even though there is no
    // function in this program that returns one.
}
</code></pre>
</li>
</ul>
<p>An alternative to self types is to use generic interfaces: instead of
an interface <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">q</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">s</mi></mrow><annotation encoding="application/x-tex">\n{Equals}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">E</span><span class="mord mathsf">q</span><span class="mord mathsf">u</span><span class="mord mathsf">a</span><span class="mord mathsf">l</span><span class="mord mathsf">s</span></span></span></span></span> with an <code>equals</code> method accepting a self
type, one can use a generic interface <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">q</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">s</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{Equals}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">E</span><span class="mord mathsf">q</span><span class="mord mathsf">u</span><span class="mord mathsf">a</span><span class="mord mathsf">l</span><span class="mord mathsf">s</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> whose <code>equals</code>
method accepts an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, and then write classes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">C</mi></mrow><annotation encoding="application/x-tex">\n{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">C</span></span></span></span></span> that implement
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">q</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">s</mi></mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{Equals}[\n{C}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">E</span><span class="mord mathsf">q</span><span class="mord mathsf">u</span><span class="mord mathsf">a</span><span class="mord mathsf">l</span><span class="mord mathsf">s</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">C</span></span><span class="mclose">]</span></span></span></span>. This is the approach taken by C#'s
<code>IEquatable&lt;T&gt;</code> and Java's <code>Comparable&lt;T&gt;</code>.</p>
<div class="footnote-definition" id="binary"><sup class="footnote-definition-label">1</sup>
<p><a href="https://core.ac.uk/download/pdf/38891811.pdf">On Binary Methods</a>, Kim Bruce, Luca Cardelli, Giuseppe
Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin
Pierce (1995)</p>
</div>
<div class="footnote-definition" id="swift"><sup class="footnote-definition-label">2</sup>
<p><a href="https://bugs.swift.org/browse/SR-10713">https://bugs.swift.org/browse/SR-10713</a> (2019)</p>
</div>
<div class="footnote-definition" id="rust"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/rust-lang/rust/issues/5781">https://github.com/rust-lang/rust/issues/5781</a> (2013)</p>
</div>
<h1><a class="header" href="#privacy-violation" id="privacy-violation">Privacy violation</a></h1>
<p><small><a href="glossary.html#subtyping">[subtyping]</a> <a href="glossary.html#variance">[variance]</a></small></p>
<p>With declaration-site variance (see <a href="covariant-containers.html">Covariant
containers</a>), a generic class can be declared
to be covariant in its type parameter, as long as the type parameter
is only used in output positions:</p>
<pre><code class="language-csharp">class Box&lt;+X&gt; {
  // allowed, X is an output (covariant)
  public X get() { ... }

  // disallowed, X is an input (contravariant)
  public void set(X x) { ... }
}
</code></pre>
<p>Since variance checking is verifying subtyping, a property of the
public interface to a class, it should in principle be fine to allow
methods that use <code>X</code> contravariantly (like <code>set</code> above), provided that
they are marked <code>private</code> and therefore do not form part of the
interface.</p>
<p>Whether or not this is sound hinges on exactly what the <code>private</code>
modifier means: is it private to the <em>object</em> or private to the
<em>class</em>? Conventionally, many object-oriented languages choose
class-private, allowing access to private fields of an object of class
<code>A</code> from any method of class <code>A</code>, regardless of whether the object
being accessed was <code>this</code> or any other.</p>
<p>Choosing class-private makes the private variance check unsound, as
pointed out by Emir et al.<sup class="footnote-reference"><a href="#csharp">1</a></sup> in their paper introducing
declaration-site variance for C#. (The same issue later reappeared in
Hack<sup class="footnote-reference"><a href="#hack">2</a></sup>).</p>
<pre><code class="language-csharp">// Counterexample by Emir et al.
class Bad&lt;+X&gt; {
  private X item;
  public void BadAccess(Bad&lt;string&gt; bs) {
    Bad&lt;object&gt; bo = bs;
    bo.item = new Button(); // we just wrote a button as a string
  }
}
</code></pre>
<pre><code class="language-hack">// Counterexample by Andrew Kennedy
class Box&lt;+T&gt; {
  // OK, we've got a private field whose type involves the covariant T
  public function __construct(private T $elem) {
  }

  // As usual, a (safe) getter method
  public function get(): T { return $this-&gt;elem; }

  // Private gives us access to arbitrary instances of Box, even in static
  // methods. Note the use of covariant subtyping to put a string in
  // a Box&lt;mixed&gt;
  public static function updateAsString(Box&lt;mixed&gt; $x, string $s) : void {
    $x-&gt;elem = $s;
  }

  // We can now use this method to overwrite an integer with a string
  // but return it as an integer
  public static function morphIntToString(int $i) : int {
    $x = new Box($i);
    Box::updateAsString($x, 'hey you turned me into a string');
    return $x-&gt;get();
  }

  // Actually do it
  public static function useBox(): void {
    $i = Box::morphIntToString(23);
    echo('this should be an integer: ' . $i);
  }
}
</code></pre>
<p>Scala supports both <code>private</code> (class-private) and <code>private[this]</code>
(object-private), with different variance checking. It also supports
<code>protected[this]</code>, an &quot;object-protected&quot; qualifier in which a field is
accessible only via <code>this</code>, but both by the class itself and its
subclasses.</p>
<p>Scala's <code>protected[this]</code> has the same variance-checking as
<code>private[this]</code>, allowing non-covariant uses of a type parameter in a
<code>protected[this]</code> field, even from within a class marked as
covariant. This is an extraordinarily subtle feature, and Scala's
current implementation has a number of soundness issues.</p>
<p>First, Scala supports a form of multiple inheritance via &quot;traits&quot;. A
class can inherit from a covariant trait in multiple ways, and the two
copies of the trait's interface are merged. This merging can be justified by
covariance, but <code>protected[this]</code> allows classes to provide
non-covariant features to subclasses. This is unsound, as different
traits in the inheritance heirarchy can see different values of the
type parameter in non-covariant ways<sup class="footnote-reference"><a href="#scala1">3</a></sup>:</p>
<pre><code class="language-scala">// Counterexample by Jason Zaugg
trait A[+X] {
  protected[this] def f(x: X): X = x
}

trait B extends A[B] {
  def kaboom = f(new B {})
}

// protected[this] disables variance checking
// of the signature of `f`.
//
// C's parent list unifies A[B] with A[C]
//
// The protected[this] loophole is widely used
// in the collections, every newBuilder method
// would fail variance checking otherwise.
class C extends B with A[C] {
  override protected[this] def f(c: C) = c
}

// java.lang.ClassCastException: B$$anon$1 cannot be cast to C
//  at C.f(&lt;console&gt;:15)
new C().kaboom
</code></pre>
<p>Second, Scala allows <code>protected[this]</code> to apply also to abstract type
members, which can be exposed by a subclass<sup class="footnote-reference"><a href="#scala2">4</a></sup>:</p>
<pre><code class="language-scala">// Counterexample by Derek Lam
abstract class Base[+T] {
  protected[this] type TSeq &lt;: MutableList[T]
  val v: TSeq
}

class Sub extends Base[Int] {
  type TSeq = MutableList[Int]
  val v = MutableList(42)
}

val x = new Sub()
(x: Base[Any]).v += &quot;string!&quot;
x.v.last + 42
// java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
</code></pre>
<div class="footnote-definition" id="csharp"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.microsoft.com/en-us/research/publication/variance-and-generalized-constraints-for-c-generics/">Variance and Generalized Constraints for C# Generics</a> (ECOOP '06), 
Burak Emir, Andrew Kennedy, Claudio Russo, Dachuan Yu (2006)</p>
</div>
<div class="footnote-definition" id="hack"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/facebook/hhvm/issues/7216#issuecomment-235726828">https://github.com/facebook/hhvm/issues/7216#issuecomment-235726828</a> (2016)</p>
</div>
<div class="footnote-definition" id="scala1"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/scala/bug/issues/7093">https://github.com/scala/bug/issues/7093</a> (2013)</p>
</div>
<div class="footnote-definition" id="scala2"><sup class="footnote-definition-label">4</sup>
<p><a href="https://github.com/scala/scala-dev/issues/370">https://github.com/scala/scala-dev/issues/370</a> (2017)</p>
</div>
<h1><a class="header" href="#unstable-type-expressions" id="unstable-type-expressions">Unstable type expressions</a></h1>
<p><small><a href="glossary.html#mutation">[mutation]</a></small></p>
<p>Types can be passed around as first-class values in several languages,
either directly (particularly in languages with dependent types and
universes) or as part of another structure (e.g. first-class modules
in OCaml, abstract type members in Scala).</p>
<p>This means that it is possible to have a type expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> that
depends on a value: if some boolean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is false, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">T = \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>,
but if it's true then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow></mrow><annotation encoding="application/x-tex">T = \n{String}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span>. In languages with mutation,
there can even be a type expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo mathvariant="normal">≠</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T ≠ T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
yields two different types when evaluated twice.</p>
<p>The risk is that if the type system does not perfectly track
dependency of types on values, or the presence of side-effects in type
expressions, then you may end up with two incompatible values both
claiming to be of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p>
<p>The problem was noticed by Russo<sup class="footnote-reference"><a href="#russo">1</a></sup>, in his thesis introducing
first-class modules to Standard ML, where he gave a counterexample
showing that the naive approach was unsound. The issue later
reappeared in Scala<sup class="footnote-reference"><a href="#scala">2</a></sup>.</p>
<pre><code class="language-sml">(* Counterexample by Claudio Russo *)
module F = functor (X:sig val b:bool end)
  unpack
    if X.b then
      pack struct
        type t = int
        val x = 1
        fun y n = -n
      end
      as sig 
        type t
        val x : t
        val y : t -&gt; t
      end
    else
      pack struct
        type t = bool
        val x = true
        fun y b = if b then false else true
      end
      as sig
        type t
        val x : t
        val y : t -&gt; t
      end
end
as sig
  type t
  val x : t
  val y : t → t
end
module A = F (struct val b = true end)
module B = F (struct val b = false end)
val z = A.y B.x
</code></pre>
<pre><code class="language-scala">// Counterexample by Vladimir Reshetnikov
trait A {
  type T
  var v : T
}

object B {
  def f(x : { val y : A }) { x.y.v = x.y.v } 
  
  var a : A = _
  var b : Boolean = false
  def y : A = {
    if(b) {
      a = new A { type T = Int; var v = 1 }
      a
    } else {
      a = new A { type T = String; var v = &quot;&quot; }
      b = true
      a
    }
  }
}

// B.f(B) causes a ClassCastException
</code></pre>
<p>There are two standard fixes:</p>
<ul>
<li>
<p><strong>Syntactically restrict expressions appearing in types</strong></p>
<p>The syntax of type expressions can be limited to constructions
whose value cannot change. See <em>paths</em> in ML-family languages and
<em>stable identifiers</em> in Scala.</p>
<p>This can lead to some surprises, because valid syntax then depends
on context. For instance, in OCaml, anonymous module parameters
are possible in module definitions but not type expressions:</p>
<pre><code class="language-ocaml">module X = struct type t = int end
module FX = F (X)                           (* ok *)
type t1 = (F (X)).t                         (* ok *)
module FX = F (struct type t = int end)     (* ok *)
type t2 = (F (struct type t = int end)).t   (* error *)
</code></pre>
<p>(Anonymous module parameters also cause other surprises: see <a href="avoidance.html">the
avoidance problem</a>)</p>
</li>
<li>
<p><strong>Restrict effects of expressions appearing in types</strong></p>
<p>If the language statically tracks effects, either directly with a
type-and-effect system or via encoding all effects in an <code>IO</code>
monad, then it is possible to check that only pure expressions are
used in types.</p>
<p>There is an additional wrinkle here: some effect systems track
mutation but allow nontermination to count as &quot;pure&quot;. Depending on
the exact system, allowing a possibly-nonterminating expression
into the type language may be unsound because of a type-level
version of the <a href="eventually-nothing.html">eventually, nothing</a> problem.</p>
</li>
</ul>
<div class="footnote-definition" id="russo"><sup class="footnote-definition-label">1</sup>
<p>Fig 7.12 on p. 270 of <a href="http://www.dcs.ed.ac.uk/home/cvr/ECS-LFCS-98-389.html">Types For Modules</a>, Claudio Russo (1998)</p>
</div>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/scala/bug/issues/2079">https://github.com/scala/bug/issues/2079</a> (2009)</p>
</div>
<!-- FIXME

Is this really the eventually, nothing issue?
Seems like the static-tracking variant that I haven't written up yet
  (if there's a type-level entity that's not obviously used,
   its existence might imply some facts that are relied on,
   so you need to evaluate it anyway in case it fails or diverges)


Are these related?
https://issues.scala-lang.org/browse/SI-515
fixed by https://github.com/scala/legacy-svn-scala/commit/febfdeae671ca5f5b80473327058613ddefd67d2
seems specific to singleton types, not sure if it's relevant here

https://issues.scala-lang.org/browse/SI-963
http://www.seas.upenn.edu/~sweirich/types/archive/1999-2003/msg01136.html

How about this?
p312,336 of TAPL2 (first-class module projections, generativity)
--><h1><a class="header" href="#the-avoidance-problem" id="the-avoidance-problem">The avoidance problem</a></h1>
<p><small><a href="glossary.html#scoping">[scoping]</a> <a href="glossary.html#subtyping">[subtyping]</a></small></p>
<p>A type system which infers types can occasionally find itself having
inferred a type that refers to something (a type, module, etc.) which
is about to go out of scope. Referring to things which are no longer
in scope is ill-formed, and doing it generally leads to unsoundness
(see <a href="scope-escape.html">Scope escape</a>).</p>
<p>So, the type system must approximate the desired type, using only
what's still in scope and avoiding the names going out of scope, which
is known as the <em>avoidance problem</em>. This is hard, and in most type
systems there is no general way to do it, and some systems employ
fragile heuristics.</p>
<p>An example of this due to Dreyer<sup class="footnote-reference"><a href="#dreyer">1</a></sup> can be found in OCaml, when a
parameterised module is instantiated with an anonymous module:</p>
<pre><code class="language-ocaml">module type S = sig type t end
module F (X : S) = struct type u = X.t type v = X.t end
module AppF = F((struct type t = int end : S))
</code></pre>
<p>Here OCaml infers the following module signature for <code>AppF</code>:</p>
<pre><code class="language-ocaml">module AppF : sig type u type v end
</code></pre>
<p>The type <code>X.t</code> is no longer in scope as the anonymous module
substituted for <code>X</code> has no name. So the signature is approximated by
leaving the types abstract. However, if the definition of <code>F</code> is
changed to an equivalent form:</p>
<pre><code class="language-ocaml">module G (X : S) = struct type u = X.t type v = u end
</code></pre>
<p>then the inferred module signature changes to the non-equivalent:</p>
<pre><code class="language-ocaml">module AppG : sig type u type v = u end
</code></pre>
<p>The approximation process fails to respect equivalences between module
signatures, which is typical of heuristic solutions to the avoidance
problem.</p>
<p>A well-behaved solution to the avoidance problem is to introduce
existential types when necessary to give names to values that have
gone out of scope. In the above example, that would lead to a
signature like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi mathvariant="sans-serif">X</mi><mo>:</mo><mi mathvariant="sans-serif">S</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mo stretchy="false">{</mo><mrow><mi mathvariant="monospace">t</mi><mi mathvariant="monospace">y</mi><mi mathvariant="monospace">p</mi><mi mathvariant="monospace">e</mi></mrow><mtext>  </mtext><mi mathvariant="monospace">u</mi><mo>=</mo><mi mathvariant="sans-serif">X</mi><mi mathvariant="normal">.</mi><mi mathvariant="monospace">t</mi><mo separator="true">;</mo><mtext>  </mtext><mrow><mi mathvariant="monospace">t</mi><mi mathvariant="monospace">y</mi><mi mathvariant="monospace">p</mi><mi mathvariant="monospace">e</mi></mrow><mtext>  </mtext><mi mathvariant="monospace">v</mi><mo>=</mo><mi mathvariant="sans-serif">X</mi><mi mathvariant="normal">.</mi><mi mathvariant="monospace">t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">∃\n{X} : \n{S}.;{ {\tt type};{\tt u} = \n{X}.{\tt t};; {\tt type}; {\tt v} = \n{X}.{\tt t} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span><span class="mord"><span class="mord mathsf">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">S</span></span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">{</span><span class="mord"><span class="mord"><span class="mord mathtt">t</span><span class="mord mathtt">y</span><span class="mord mathtt">p</span><span class="mord mathtt">e</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathtt">u</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9166599999999999em;vertical-align:-0.22222em;"></span><span class="mord"><span class="mord mathsf">X</span></span><span class="mord">.</span><span class="mord"><span class="mord"><span class="mord mathtt">t</span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathtt">t</span><span class="mord mathtt">y</span><span class="mord mathtt">p</span><span class="mord mathtt">e</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathtt">v</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">X</span></span><span class="mord">.</span><span class="mord"><span class="mord"><span class="mord mathtt">t</span></span></span><span class="mclose">}</span></span></span></span>.
The details of when and how to introduce such existentials can be
quite tricky, see Crary<sup class="footnote-reference"><a href="#crary">2</a></sup> for a recent approach.</p>
<p>Languages with subtyping and top/bottom types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">y</mi></mrow><annotation encoding="application/x-tex">\n{Any}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">A</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow><annotation encoding="application/x-tex">\n{Nothing}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">o</span><span class="mord mathsf">t</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span> can
sometimes use a different solution to the avoidance problem: types that go out
of scope are approximated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">y</mi></mrow><annotation encoding="application/x-tex">\n{Any}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">A</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span></span></span></span> when used covariantly (as an
output) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow><annotation encoding="application/x-tex">\n{Nothing}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">o</span><span class="mord mathsf">t</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span> when used contravariantly (as an input). For
instance, when the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> goes out of scope, a function of type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[A] → \n{List}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> becomes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">y</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{List}[\n{Nothing}] → \n{List}[\n{Any}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">o</span><span class="mord mathsf">t</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">A</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span><span class="mclose">]</span></span></span></span>.</p>
<p>Scala uses this approach. However, due to the presence of constraints
in Scala types (a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> may be well-defined only for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>),
it is not always valid to replace occurrences of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">y</mi></mrow><annotation encoding="application/x-tex">\n{Any}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">A</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span></span></span></span> or
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">h</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow><annotation encoding="application/x-tex">\n{Nothing}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">o</span><span class="mord mathsf">t</span><span class="mord mathsf">h</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span>.  This caused a bug in Scala<sup class="footnote-reference"><a href="#scala">3</a></sup>, where invalid types were
sometimes inferred:</p>
<pre><code class="language-scala">// Counterexample by Guillaume Martres
class Contra[-T &gt;: Null]

object Test {
  def foo = {
    class A
    new Contra[A]
  }
}
// The inferred type of foo is Contra[Nothing],
// but this isn't a legal type
</code></pre>
<div class="footnote-definition" id="dreyer"><sup class="footnote-definition-label">1</sup>
<p>Fig 4.12 on p. 79 of <a href="https://www.cs.cmu.edu/%7Erwh/theses/dreyer.pdf">Understanding and Evolving the ML
Module System</a>, Derek
Dreyer (2005)</p>
</div>
<div class="footnote-definition" id="crary"><sup class="footnote-definition-label">2</sup>
<p><a href="https://www.cs.cmu.edu/%7Ecrary/papers/2020/exsig.pdf">A Focused Solution to the Avoidance Problem</a>, Karl Crary (2020)</p>
</div>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/lampepfl/dotty/issues/6205">https://github.com/lampepfl/dotty/issues/6205</a> (2019)</p>
</div>
<h1><a class="header" href="#a-little-knowledge" id="a-little-knowledge">A little knowledge...</a></h1>
<p><small><a href="glossary.html#abstract-types">[abstract-types]</a></small></p>
<p>The general principle broken by this counterexample is not soundness
but <em>monotonicity</em>: given more knowledge about the program, the
compiler should do a better job compiling it.</p>
<p>The concrete instance of this principle here is to do with abstract
types: if the implementation of a previously-hidden abstract type is
exposed, no program that previously typechecked should now fail to.</p>
<p>Violating this property does not cause crashes, but is
confusing. Refactoring becomes tricky if loosening abstraction
boundaries can cause programs to stop working.</p>
<p>This property does not hold in OCaml, due to an optimisation that uses
a special representation for a record containing only floating-point
numbers (which are usually boxed in OCaml). Since this
representation is incompatible with the normal one, it is possible for
a program to depend on the optimisation <em>not</em> being applied:</p>
<pre><code class="language-ocaml">module F : sig
 (* Deleting '= float' on the line below
    makes this program compile *)
 type t = float
end = struct
 type t = float
end

module M : sig
 type t
 type r = { foo : t }
end = struct
 type t = F.t
 type r = { foo : t }
end
</code></pre>
<h1><a class="header" href="#underdetermined-recursion" id="underdetermined-recursion">Underdetermined recursion</a></h1>
<p><small><a href="glossary.html#recursive-types">[recursive-types]</a></small></p>
<p>Most type systems permit some flavour of recursive types, allowing the
programmer to define, say, the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> representing lists
of integers. A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> consists of either the empty list, or a
pair of an integer and a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>, giving the recursive equation:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>≅</mo><mn>1</mn><mo>+</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">
\n{ListInt} \cong 1 + \n{Int} × \n{ListInt}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span></span>
There are two ways to interpret the symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> above:</p>
<ul>
<li>
<p><strong>Isorecursive types</strong>: there is an explicitly defined
datatype/class <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>, and we must use its
constructors/methods to convert between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">1 +
\n{Int} × \n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>. The symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> is read as &quot;is
isomorphic to&quot;.</p>
</li>
<li>
<p><strong>Equirecursive types</strong>: the types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">1 + \n{Int}
× \n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> are the same type, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> is
identified with the infinite expansion:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>+</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
1 + \n{Int} × (1 + \n{Int} × (1 + (\n{Int} × \dots)))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>
The symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> is read as &quot;equals&quot;.</p>
</li>
</ul>
<p>With equirecursive types, there can only be a single solution to a
recursive equation. If I have another type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> satisfying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A = 1 +
\n{Int} × A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, then the infinite expansions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>
are equal, so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">A = \n{ListInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">L</span><span class="mord mathsf">i</span><span class="mord mathsf">s</span><span class="mord mathsf">t</span><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>. With isorecursive types, on the other
hand, there can be two different datatypes/classes with the same
pattern of recursion, which the type system does not necessarily
consider equal.</p>
<p>The assumption that recursive type equations have only a single
solution can lead to unsoundness when combined with higher-kinded
types. If it is possible to abstract over a type constructor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and
two types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> satisfying:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>B</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}A &amp;= F[A] \ B &amp;= F[B] \end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span>
then type systems equirecursive types will assume that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, since
they have the same infinite expansion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>F</mi><mo stretchy="false">[</mo><mi>F</mi><mo stretchy="false">[</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[F[F[\dots]]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">]</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>.</p>
<p>This is unsound for arbitrary type-level functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> because there
can be multiple solutions for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X = F[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span>. For instance:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>X</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>B</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
F[X] &amp;= X \
A &amp;= \n{Int} \
B &amp;= \n{String}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>This problem has arisen in OCaml<sup class="footnote-reference"><a href="#ocaml">1</a></sup>:</p>
<pre><code class="language-ocaml">(* Counterexample by Stephen Dolan *)
type (_, _) eq = Eq : ('a, 'a) eq
let cast : type a b . (a, b) eq -&gt; a -&gt; b =
  fun Eq x -&gt; x

module Fix (F : sig type 'a f end) = struct
  type 'a fix = ('a, 'a F.f) eq
  let uniq (type a) (type b)
    (Eq : a fix) (Eq : b fix) : (a, b) eq =
    Eq
end

module FixId = Fix (struct type 'a f = 'a end)
let bad : (int, string) eq = FixId.uniq Eq Eq
let _ = Printf.printf &quot;Oh dear: %s&quot; (cast bad 42)
</code></pre>
<div class="footnote-definition" id="ocaml"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/6992">https://github.com/ocaml/ocaml/issues/6992</a> (2015)</p>
</div>
<h1><a class="header" href="#overdetermined-recursion" id="overdetermined-recursion">Overdetermined recursion</a></h1>
<p><small><a href="glossary.html#recursive-types">[recursive-types]</a></small></p>
<p>While the previous example (<a href="underdetermined-recursion.html">Underdetermined
recursion</a>) was concerned with recursive
type definitions that have multiple valid interpretations, here the
problem is recursive type definitions that have no valid
interpretations at all.</p>
<p>When type systems allow constraints on type parameters, type
declarations must be checked to see that the constraints are
valid. For instance, Scala correctly rejects the following type
declaration:</p>
<pre><code class="language-scala">type A &gt;: String &lt;: Int
// Error: lower bound String does not conform to upper bound Int
</code></pre>
<p>This purports to declare a type <code>A</code> which is both a subtype of
<code>Int</code> and a supertype of <code>String</code>, but this would incorrectly imply
that <code>String</code> was a subtype of <code>Int</code>.</p>
<p>However, a similar example is accepted<sup class="footnote-reference"><a href="#scala">1</a></sup>, if the invalid declaration is
split across two recursive definitions:</p>
<pre><code class="language-scala">// Counterexample by Nada Amin
trait O { type A &gt;: Any &lt;: B; type B &gt;: A &lt;: Nothing }
val o = new O {}
def id(a: Any): Nothing = (a: o.B)
id(&quot;Boom&quot;)
</code></pre>
<p>The <code>Any &lt;: B</code> check that is required by the declaration of <code>A</code>
passes, because <code>Any &lt;: A</code> (by the declaration of <code>A</code>) and <code>A &lt;: B</code>
(by the declaration of <code>B</code>). In effect, circular reasoning occurs
here, where each half of the recursive definition is used to justify
the other.</p>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/scala/bug/issues/9715">https://github.com/scala/bug/issues/9715</a> (2016)</p>
</div>
<h1><a class="header" href="#scope-escape" id="scope-escape">Scope escape</a></h1>
<p><small><a href="glossary.html#scoping">[scoping]</a> <a href="glossary.html#polymorphism">[polymorphism]</a></small></p>
<p>When both polymorphism (generic functions) and type inference are
present, an issue known as <em>scope escape</em> can arise. Suppose that
inside the scope of a variable <code>f</code> whose type is being inferred, we
define a polymorphic function of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">∀ α . α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>. While
type-checking this function, we must ensure that we do not
accidentally infer a type for <code>f</code> that mentions the polymorphic
variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, as it was not in scope when <code>f</code> was introduced.</p>
<p>Languages that mix type inference and polymorphic definitions must
check that this does not occur:</p>
<pre><code class="language-haskell">{-# LANGUAGE RankNTypes #-}

idful :: (forall a. a -&gt; a) -&gt; (Int,String)
idful id = (id 5, id &quot;hello&quot;)

g f = idful (\x -&gt; let _ = f x in x)
-- GHC error:
--     Couldn't match expected type ‘a -&gt; p0’ with actual type ‘p’
--     because type variable ‘a’ would escape its scope
</code></pre>
<pre><code class="language-ocaml">type idful = { id : 'a . 'a -&gt; 'a }
let idful i = i.id 5, i.id &quot;hello&quot;

let g f = idful { id = fun x -&gt; f x; x }
(* Error: This field value has type 'b -&gt; 'b which is less general than
         'a. 'a -&gt; 'a *)
</code></pre>
<p>Above, the <code>idful</code> function requires an argument of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">∀α. α → α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>,
but the function it is given leaks its argument to <code>f</code>. Naively, we
might infer f takes arguments of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, but this is invalid as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>
is not in scope outside the argument to <code>idful</code>.</p>
<p>The consequences of accidental scope escape are often an internal
error later in the compiler, when it tries to examine the invalid type
that mentions an out-of-scope variable. If scope escape does not cause
the compiler to crash, it is often a soundness issue: inferred types
that escape their scope can cause, for instance, the creation of
<a href="polymorphic-references.html">polymorphic references</a>.</p>
<p>Scope escape bugs have occurred at one time or another in almost every
implementation of polymorphism (especially higher-rank polymorphism),
including Haskell<sup class="footnote-reference"><a href="#haskell">1</a></sup>, OCaml<sup class="footnote-reference"><a href="#ocaml">2</a></sup>, Rust<sup class="footnote-reference"><a href="#rust">3</a></sup> and
Scala<sup class="footnote-reference"><a href="#scala">4</a></sup>:</p>
<pre><code class="language-haskell">-- Counterexample by Simon Peyton Jones
{-# LANGUAGE MultiParamTypeClasses, TypeFamilies, FlexibleContexts #-} 

module Foo where

type family F a

class C b where {}

foo :: a -&gt; F a
foo x = error &quot;urk&quot;

h :: (b -&gt; ()) -&gt; Int
h = error &quot;urk&quot;

f = h (\x -&gt; let g :: C (F a) =&gt; a -&gt; Int
                 g y = length [x, foo y]
             in ())
-- Causes an internal compiler error in Core Lint
</code></pre>
<pre><code class="language-ocaml">(* Counterexample by Leo White *)
let (n : 'b -&gt; &lt; m : 'a . ([&lt; `Foo of int] as 'b) -&gt; 'a &gt;) = 
  fun x -&gt; object
    method m : 'x. [&lt; `Foo of 'x] -&gt; 'x = fun x -&gt; assert false
  end;;
(* Type inference gave:
   Error: Values do not match:
          val n : ([&lt; `Foo of int &amp; 'a ] as 'b) -&gt; &lt; m : 'a0. 'b -&gt; 'a0 &gt;
        is not included in
          val n : ([&lt; `Foo of int &amp; 'a ] as 'b) -&gt; &lt; m : 'a0. 'b -&gt; 'a0 &gt;
   Note the &amp; 'a in the argument type.
   That is the univar from 'a . ([&lt; `Foo of int] as 'b) -&gt; 'a.
   (Unknown whether this is a soundness issue) *)
</code></pre>
<pre><code class="language-_rust">// Counterexample by @WildCryptoFox
fn f&lt;I&gt;(i: I)
where
    I: IntoIterator,
    I::Item: for&lt;'a&gt; Into&lt;&amp;'a ()&gt;,
{}

fn main() {
    // triggers internal compiler error
    f(&amp;[f()]);
}
</code></pre>
<pre><code class="language-scala">// Counterexample by Nada Amin
object Test {
  trait A { a =&gt;
    type X
    val x: a.X
  }
  val a = new A {
    type X = Int
    val x = 1
  }
  def f(arg: A): arg.X = arg.x
  val x = f(a: A)
  // Inferred type of x references out-of-scope 'arg'
  // (Still unknown whether this is a soundness issue)
}
</code></pre>
<p>Scope escape bugs are notably absent from Idris 2<sup class="footnote-reference"><a href="#idris2">5</a></sup>, a self-hosting
dependently-typed language whose compiler encodes scoping in the types
it uses to manipulate programs, so that the compiler successfully
builds only if it does not have any scope escape errors.</p>
<div class="footnote-definition" id="haskell"><sup class="footnote-definition-label">1</sup>
<p><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/7194">https://gitlab.haskell.org/ghc/ghc/-/issues/7194</a> (2012)</p>
</div>
<div class="footnote-definition" id="ocaml"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/ocaml/ocaml/issues/6744">https://github.com/ocaml/ocaml/issues/6744</a> (2015)</p>
</div>
<div class="footnote-definition" id="rust"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/rust-lang/rust/issues/58451">https://github.com/rust-lang/rust/issues/58451</a> (2019)</p>
</div>
<div class="footnote-definition" id="scala"><sup class="footnote-definition-label">4</sup>
<p><a href="https://github.com/scala/bug/issues/7084">https://github.com/scala/bug/issues/7084</a> (2013)</p>
</div>
<div class="footnote-definition" id="idris2"><sup class="footnote-definition-label">5</sup>
<p><a href="https://idris2.readthedocs.io/en/latest/implementation/overview.html">https://idris2.readthedocs.io/en/latest/implementation/overview.html</a> (2020)</p>
</div>
<h1><a class="header" href="#under-false-pretenses" id="under-false-pretenses">Under false pretenses</a></h1>
<p><small><a href="glossary.html#empty-types">[empty-types]</a> <a href="glossary.html#equality">[equality]</a></small></p>
<p>The empty type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> has no values, so a variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x : 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> can never be
supplied. So, any code within the scope of such a variable can never
be executed. (For a lazy language like Haskell, read &quot;underneath a
case split on&quot; instead of &quot;within the scope of&quot;).</p>
<p>In such unreachable scopes, many type systems become a little
strange. This strangeness is not by itself a problem, as it can only
arise in unreachable code, but care must be taken to keep it contained.</p>
<p>For example, it is possible in such a scope to construct an expression
of a equality type, &quot;proving&quot; that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><annotation encoding="application/x-tex">\n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow><annotation encoding="application/x-tex">\n{String}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span> are
equal:</p>
<pre><code class="language-ocaml">type empty = |
type (_,_) eq =
  Refl : ('a, 'a) eq
let f (x : empty) =
  let eq : (int, string) eq = match x with _ -&gt; . in
  ...
</code></pre>
<pre><code class="language-haskell">{-# LANGUAGE EmptyCase #-}
data Empty
data Eq a b where
  Refl :: Eq a a

f :: Empty -&gt; ...
f x = ...
  where
    eq : Eq Int String
    eq = case x of {}
</code></pre>
<p>If use of <code>eq</code> introduces the equation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow></mrow><annotation encoding="application/x-tex">\n{Int} = \n{String}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span>, then
you may end up with nonsensical expressions such as <code>20 - &quot;hello&quot;</code>
becoming well-typed. This can interfere with compiler optimisations:
the <em>constant folding</em> optimisation eagerly computes arithmetic
operations whose arguments are constant, and may not be able to
handle, say, subtraction of a string from an integer, even in dead
code. Generally, hoisting optimisations (those which move an
expression to an earlier position) must be treated carefully, as they
risk moving a nonsensical computation from dead code to code that
actually runs.</p>
<p>In type systems based on Martin-Löf's Intensional Type Theory, a more
subtle issue can arise. ITT-based systems have a relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ≡ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
called <em>definitional equality</em> (or <em>judgemental equality</em>).
Definitional equality determines which expressions are considered
&quot;obviously equal&quot; (that is, can be substituted for each other in any
context with no explicit coercion required), and part of the design of
an ITT-based type system is to decide which rules can be included in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">≡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> while keeping the relation decidable.</p>
<p>In the presence of an empty type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it is tempting to make any two
functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo>:</mo><mn>0</mn><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f, g : 0 → A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> definitionally equal, as there is only one
possible function from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> to any type. However, as noted by
McBride<sup class="footnote-reference"><a href="#ripley">1</a></sup>, this choice breaks decidability of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">≡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span>, because
under the scope of a variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x : 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, we have:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">e</mi></mrow><mo>≡</mo><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mrow><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">e</mi></mrow><mo stretchy="false">)</mo><mi>x</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mrow><mi mathvariant="sans-serif">f</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">e</mi></mrow><mo stretchy="false">)</mo><mi>x</mi><mo>≡</mo><mrow><mi mathvariant="sans-serif">f</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">e</mi></mrow></mrow><annotation encoding="application/x-tex">
\n{true} ≡ (λ (y : 0). \n{true}) x ≡ (λ (y : 0). \n{false}) x ≡ \n{false}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">u</span><span class="mord mathsf">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">.</span><span class="mord"><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">u</span><span class="mord mathsf">e</span></span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">.</span><span class="mord"><span class="mord mathsf" style="margin-right:0.06944em;">f</span><span class="mord mathsf">a</span><span class="mord mathsf">l</span><span class="mord mathsf">s</span><span class="mord mathsf">e</span></span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf" style="margin-right:0.06944em;">f</span><span class="mord mathsf">a</span><span class="mord mathsf">l</span><span class="mord mathsf">s</span><span class="mord mathsf">e</span></span></span></span></span></span></p>
<p>So, in order to decide whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">e</mi></mrow><mo>≡</mo><mrow><mi mathvariant="sans-serif">f</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">l</mi><mi mathvariant="sans-serif">s</mi><mi mathvariant="sans-serif">e</mi></mrow></mrow><annotation encoding="application/x-tex">\n{true} ≡ \n{false}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">u</span><span class="mord mathsf">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf" style="margin-right:0.06944em;">f</span><span class="mord mathsf">a</span><span class="mord mathsf">l</span><span class="mord mathsf">s</span><span class="mord mathsf">e</span></span></span></span></span>, we would first
need to decide whether the type of any variable in scope is or can be
converted to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, which is not in general decidable.</p>
<div class="footnote-definition" id="ripley"><sup class="footnote-definition-label">1</sup>
<p><a href="http://strictlypositive.org/Ripley.pdf">Grins from my Ripley
Cupboard</a>, Conor McBride,
2009.</p>
</div>
<h1><a class="header" href="#suspicious-subterms" id="suspicious-subterms">Suspicious subterms</a></h1>
<p><small><a href="glossary.html#totality">[totality]</a></small></p>
<p>In <em>total</em> languages, all well-typed expressions terminate and
infinite loops are impossible. This property is relied upon by proof
assistants like Coq and Agda: if the result of a subexpression is not
needed to compute the output of a program, then the subexpression is
discarded. This is an important optimisation in a proof assistant,
because large parts of the program are often proofs about other parts
of the program, and not directly used in computations. However, this
optimisation means that any source of nontermination immediately
causes a soundness issue, of the sort described in <a href="eventually-nothing.html">Eventually,
nothing</a>.</p>
<p>To remain sound, these languages must check that all recursive
functions eventually terminate. This is usually done by checking that
when the function recurses, the argument it passes itself is a
strictly smaller part of the argument it received, making infinite
recursion impossible.</p>
<p>The tricky part of this is the <em>subterm check</em>, which determines
whether one expression a strictly smaller part (a &quot;subterm&quot;) of
another. Coq, in particular, has an extensive subterm check, accepting
as subterms of <code>u</code> not just direct subterms but also:</p>
<ul>
<li>
<p><code>match ... with p1 -&gt; c1 | p2 -&gt; c2 | ... end</code></p>
<p>if each possible result <code>cN</code> is a subterm of <code>u</code></p>
</li>
<li>
<p><code>fun x =&gt; c</code></p>
<p>if the result <code>c</code> is a subterm of <code>u</code></p>
</li>
</ul>
<p>This resulted in unsoundness when combined with <em>propositional
extensionality</em>, an assumption widely used and available in the Coq
standard library, although not made by default. Propositional
extensionality states that two propositions which are equivalent are
also equal: roughly, this states that the only information in a
proposition carries is whether or not it is true. The details of
proofs can be discarded, identifying all true propositions with each
other, and likewise for false ones.</p>
<p>One particular consequence of this is that <code>False -&gt; False</code> and <code>True</code>
become equal, as both are true. This led to an unsoundness in Coq<sup class="footnote-reference"><a href="#coq">1</a></sup>:</p>
<pre><code class="language-coq">(* Counterexample by Maxime Dénès *)
Require Import ClassicalFacts.

Section func_unit_discr.
Hypothesis Heq : (False -&gt; False) = True.
Fixpoint contradiction (u : True) : False :=
  contradiction (
    match Heq in (_ = T) return T with
    | eq_refl =&gt; fun f:False =&gt; match f with end
    end
  ).
End func_unit_discr.

Lemma foo : provable_prop_extensionality -&gt; False.
Proof.
  intro; apply contradiction.
  apply H.
  trivial.
  trivial.
Qed.
</code></pre>
<p>The issue is that Coq's subterm check accepted the argument above as a
subterm of <code>u : True</code>, which should not have any subterms. By Coq's
definition of &quot;subterm&quot;, the expression <code>match f with end</code> is a
subterm of <code>u</code> because each of its zero possible results is a subterm
of <code>u</code>. The fix was to restrict the subterm check in the presence of
dependent matches, like the outer <code>match</code>.</p>
<p>Agda's subterm checker has also been confused by dependent matching on
type equalities, as this counterexample shows<sup class="footnote-reference"><a href="#agda">2</a></sup>:</p>
<pre><code class="language-agda">-- Andreas Abel, 2014-01-10
-- Code by Jesper Cockx and Conor McBride and folks from the Coq-club

{-# OPTIONS --without-K #-}

-- An empty type.

data Zero : Set where

-- A unit type as W-type.

mutual
  data WOne : Set where wrap : FOne -&gt; WOne
  FOne = Zero -&gt; WOne

-- Type equality.

data _&lt;-&gt;_ (X : Set) : Set -&gt; Set where
  Refl : X &lt;-&gt; X

-- This postulate is compatible with univalence:

postulate
  iso : WOne &lt;-&gt; FOne

-- But accepting that is incompatible with univalence:

noo : (X : Set) -&gt; (WOne &lt;-&gt; X) -&gt; X -&gt; Zero
noo .WOne Refl (wrap f) = noo FOne iso f

-- Matching against Refl silently applies the conversion
-- FOne -&gt; WOne to f.  But this conversion corresponds
-- to an application of wrap.  Thus, f, which is really
-- (wrap f), should not be considered a subterm of (wrap f)
-- by the termination checker.
-- At least, if we want to be compatible with univalence.

absurd : Zero
absurd = noo FOne iso (\ ())
</code></pre>
<p>Finally, both Coq and Agda had a related soundness issue using
coinductive rather than inductive types. Coinductive types contain
possibly-infinite values, and instead of the subterm check (which
verifies that recursive functions do not loop infinitely when
consuming a value) they use the <em>guardedness check</em> (which verifies
that recursive definitions do not loop infinitely when producing a
value).</p>
<p>As above, the guardedness checker was confused by dependent pattern
matching on type equalities arising from propositional extensionality,
and permitted definitions that looped unproductively<sup class="footnote-reference"><a href="#cocoq">3</a></sup><sup class="footnote-reference"><a href="#coagda">4</a></sup>:</p>
<pre><code class="language-coq">(* Counterexample by Maxime Dénès *)
CoInductive CoFalse : Prop := CF : CoFalse -&gt; False -&gt; CoFalse.

CoInductive Pandora : Prop := C : CoFalse -&gt; Pandora.

Axiom prop_ext : forall P Q : Prop, (P&lt;-&gt;Q) -&gt; P = Q.

Lemma foo : Pandora = CoFalse.
  apply prop_ext.
  constructor.
  intro x; destruct x; assumption.
  exact C.
Qed.

CoFixpoint loop : CoFalse :=
  match foo in (_ = T) return T with eq_refl =&gt; C loop end.

Definition ff : False := match loop with CF _ t =&gt; t end.
</code></pre>
<pre><code class="language-agda">-- Counterexample by Andreas Abel
open import Common.Coinduction
open import Common.Equality

prop = Set

data False : prop where

data CoFalse : prop where
  CF : False → CoFalse

data Pandora : prop where
  C : ∞ CoFalse → Pandora

postulate
  ext : (CoFalse → Pandora) → (Pandora → CoFalse) → CoFalse ≡ Pandora

out : CoFalse → False
out (CF f) = f

foo : CoFalse ≡ Pandora
foo = ext (λ{ (CF ()) }) (λ{ (C c) → CF (out (♭ c))})

loop : CoFalse
loop rewrite foo = C (♯ loop)

false : False
false = out loop
</code></pre>
<div class="footnote-definition" id="coq"><sup class="footnote-definition-label">1</sup>
<p><a href="https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html">https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html</a> (coq-club mailing list), Maxime Dénès (2013)</p>
</div>
<div class="footnote-definition" id="agda"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/agda/agda/issues/1023/">https://github.com/agda/agda/issues/1023/</a> (2015)</p>
</div>
<div class="footnote-definition" id="cocoq"><sup class="footnote-definition-label">3</sup>
<p><a href="https://sympa.inria.fr/sympa/arc/coq-club/2014-02/msg00215.html">https://sympa.inria.fr/sympa/arc/coq-club/2014-02/msg00215.html</a> (coq-club mailing list), Maxime Dénès (2014)</p>
</div>
<div class="footnote-definition" id="coagda"><sup class="footnote-definition-label">4</sup>
<p><a href="https://sympa.inria.fr/sympa/arc/coq-club/2014-03/msg00020.html">https://sympa.inria.fr/sympa/arc/coq-club/2014-03/msg00020.html</a> (coq-club mailing list), Andreas Abel (2014)</p>
</div>
<!--
  FIXME: is this really eventually-nothing?
   Seems more like the static-type missing gadt value version.
--><h1><a class="header" href="#theres-only-one-leibniz" id="theres-only-one-leibniz">There's only one Leibniz</a></h1>
<p><small><a href="glossary.html#equality">[equality]</a></small></p>
<p>Leibniz's characterisation of what it means for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> to equal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is
that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> holds for any property <nobr><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>,</nobr> then so does <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>. In
other words, equality is the relation that allows substitution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> in any context.</p>
<p>There can only be one reflexive relation with this substitution
property.  If we have two substitutive reflexive relations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≃</span></span></span></span>, then as soon as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∼</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \sim B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> we can substitute the second
occurrence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \simeq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, so
necessarily <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≃</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \simeq B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> too.</p>
<p>Haskell<sup class="footnote-reference"><a href="#haskell">1</a></sup> had a soundness issue that arose from trying to have
two distinct equality-like relations<sup class="footnote-reference"><a href="#conor">2</a></sup>. Haskell supports
<code>newtype</code>, a mechanism for creating a new copy <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> of a
previously-defined type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, and the <code>GeneralizedNewtypeDeriving</code>
mechanism allowed any typeclass that had been implemented for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> to be
automatically derived for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><code>GeneralizedNewtypeDeriving</code> was therefore a form of substitution in
an arbitrary context, which was in conflict with the equality relation
in the rest of Haskell's type system, which considered <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>
distinct. In particular, type families are allowed to distinguish <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, leading to this counterexample:</p>
<pre><code class="language-haskell">-- Counterexample by Stefan O'Rear
{-# OPTIONS_GHC -ftype-families #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
data family Z :: * -&gt; *

newtype Moo = Moo Int

newtype instance Z Int = ZI Double
newtype instance Z Moo = ZM (Int,Int)

newtype Moo = Moo Int deriving(IsInt)
class IsInt t where
    isInt :: c Int -&gt; c t
instance IsInt Int where isInt = id
main = case isInt (ZI 4.0) of
         ZM tu -&gt; print tu -- segfaults
</code></pre>
<p>The fix in Haskell was to introduce <em>roles</em><sup class="footnote-reference"><a href="#roles">3</a></sup>, implicitly
annotating each type and type parameter according to whether it was
used in a context allowing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T = T'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> (the <em>representational role</em>,
allowing efficient coercions between newtypes and their underlying
types) or an a context assuming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo mathvariant="normal">≠</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T \neq T'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> (the <em>nominal role</em>, used
in type families). For more on roles, see the GHC wiki<sup class="footnote-reference"><a href="#rolewiki">4</a></sup>.</p>
<div class="footnote-definition" id="haskell"><sup class="footnote-definition-label">1</sup>
<p><a href="https://ghc.haskell.org/trac/ghc/ticket/1496">https://ghc.haskell.org/trac/ghc/ticket/1496</a> (2007)</p>
</div>
<div class="footnote-definition" id="conor"><sup class="footnote-definition-label">2</sup>
<p>The characterisation of this issue as two conflicting equalities is <a href="https://www.reddit.com/r/haskell/comments/y8kca/generalizednewtypederiving_is_very_very_unsafe/c5tawm8/">due to Conor McBride</a></p>
</div>
<div class="footnote-definition" id="roles"><sup class="footnote-definition-label">3</sup>
<p><a href="https://dl.acm.org/doi/abs/10.1145/2628136.2628141">Safe Zero-cost Coercions for Haskell</a> (ICFP '14), Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones, Stephanie Weirich (2014)</p>
</div>
<div class="footnote-definition" id="rolewiki"><sup class="footnote-definition-label">4</sup>
<p><a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/roles">https://gitlab.haskell.org/ghc/ghc/-/wikis/roles</a></p>
</div>
<h1><a class="header" href="#intersecting-references" id="intersecting-references">Intersecting references</a></h1>
<p><small><a href="glossary.html#mutation">[mutation]</a> <a href="glossary.html#subtyping">[subtyping]</a></small></p>
<p>Intersection types are types of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> which contain those
values that are both of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> and of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. Given such a value,
it can be used as either one of the types:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow></mfrac><mspace width="2em"/><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{Γ ⊢ e : A ∧ B}{Γ ⊢ e : A} \qquad \frac{Γ ⊢ e : A ∧ B}{Γ ⊢ e : B}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Languages differ in how intersection types may be constructed. The
first style is that an expression has type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> if it has both
types, possibly by separate derivations:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mspace width="2em"/><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mo>∧</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{Γ ⊢ e : A \qquad Γ ⊢ e : B}{Γ ⊢ e : A ∧ B}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:2em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>The second style is to use subtyping, and define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> as a meet in
the subtyping order, so that:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>≤</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mtext>  </mtext><mtext>  </mtext><mtext> iff </mtext><mtext>  </mtext><mtext>  </mtext><mi>X</mi><mo>≤</mo><mi>A</mi><mtext> and </mtext><mi>X</mi><mo>≤</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">
X ≤ A ∧ B ;;\text{ iff };; X ≤ A \text{ and } X ≤ B
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord"> iff </span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p>In this style, an expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> can be given type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> by first
typechecking it with some type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> which is a subtype of both, and
then using the above rule and subtyping to give it type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</p>
<p>The crucial difference is that in the first style, the two typing
derivations for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e : B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> may be entirely different.
This brings surprising complexity: for instance, in both the
Coppo-Dezani<sup class="footnote-reference"><a href="#cdtypes">1</a></sup> and Barendregt-Coppo-Dezani<sup class="footnote-reference"><a href="#bcdtypes">2</a></sup> systems
(both simply typed lambda calculi with intersection types), type
checking is undecidable as a term is typeable iff its execution
terminates!</p>
<p>The counterexample here, however, is about the interaction between
these types and mutability, a phenomenon pointed out by Davies and
Pfenning<sup class="footnote-reference"><a href="#intereffects">3</a></sup>. First, a naive implementation of ML-style
references is unsound:</p>
<pre><code class="language-ML">(* Counterexample by Rowan Davies and Frank Pfenning *)
(* Suppose we have types nat and pos,
   where nat is nonnegative integers
   and pos is its subtype of positive integers *)
let x : nat ref ∧ pos ref = ref 1 in
let () = (x := 0) in   (* typechecks: x is a nat ref *)
let z : pos = !x in    (* typechecks: x is a pos ref *)
z : pos                (* now we have the positive number zero *)
</code></pre>
<p>Despite the lack of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">∀</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span> symbol, this is essentially the same
problem as in <a href="polymorphic-references.html">Polymorphic references</a>: the
same single reference is used at two different types. The same
solutions apply, in particular, the value restriction.</p>
<p>However, there is a further potential source of unsoundness. In many
systems with subtyping and intersection types, it is conventional to have:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>C</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>A</mi><mo>→</mo><mo stretchy="false">(</mo><mi>B</mi><mo>∧</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
(A → B) ∧ (A → C) ≤ A → (B ∧ C)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></span></p>
<p>That is, a value which is both a function that returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and a
function that returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> must be a function which returns values that
are both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</p>
<p>Even in the presence of the value restriction, type systems with
intersection types and the above rule are unsound:</p>
<pre><code class="language-ML">(* Counterexample by Rowan Davies and Frank Pfenning *)
let f : (unit → nat ref) ∧ (unit → pos ref) =
  fun () → ref 1 in        (* passes the value restriction *)
let f' : unit → (nat ref ∧ pos ref) =
  f in                     (* uses the above rule *)
let x : nat ref ∧ pos ref = f ()
let () = (x := 0) in
let z : pos = !x in
z : pos                    (* same problem as before *)
</code></pre>
<p>Note that both of these counterexamples rely on the first style of
intersection types above, where intersections can be introduced with
two different typing derivations. They do not arise if intersections
are available only through subtyping, as in the second style.</p>
<div class="footnote-definition" id="cdtypes"><sup class="footnote-definition-label">1</sup>
<p><a href="https://projecteuclid.org/euclid.ndjfl/1093883253">An extension of the basic functionality theory for the
λ-calculus</a>,
M. Coppo and M. Dezani-Ciancaglini (1980)</p>
</div>
<div class="footnote-definition" id="bcdtypes"><sup class="footnote-definition-label">2</sup>
<p><a href="https://www.jstor.org/stable/2273659?seq=1#metadata_info_tab_contents">A filter lambda model and the completeness of type
assignment</a>,
Barendregt, Coppo and Dezani-Ciancaglini (1983)</p>
</div>
<div class="footnote-definition" id="intereffects"><sup class="footnote-definition-label">3</sup>
<p><a href="https://dl.acm.org/doi/abs/10.1145/351240.351259">Intersection Types and Computational Effects</a>, Rowan Davies and Frank Pfenning (2000)</p>
</div>
<h1><a class="header" href="#polymorphic-union-refinement" id="polymorphic-union-refinement">Polymorphic union refinement</a></h1>
<p><small><a href="glossary.html#polymorphism">[polymorphism]</a> <a href="glossary.html#typecase">[typecase]</a></small></p>
<p>Untagged union types are types of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∨ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> that contain values
that are either of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> or of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, with no &quot;tag&quot; information to
denote which is which:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mo>∨</mo><mi>B</mi></mrow></mfrac><mspace width="2em"/><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mo>∨</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{Γ ⊢ e : A}{Γ ⊢ e : A ∨ B} \qquad \frac{Γ ⊢ e : B}{Γ ⊢ e : A ∨ B}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Operationally, there is no obvious way to use an untagged union type:
unlike a <em>disjoint union</em> type, which contains an additional tag bit,
there is no general-purpose <code>match</code> expression that can extract either
the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> or the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</p>
<p>For languages with runtime type introspection, some systems of
<em>refinement types</em> enable consumption of union types. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x : A ∨ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is
found via a runtime type test to not be of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, then it may be used
at type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. For instance, the following programs are valid Flow and
also valid TypeScript:</p>
<pre><code class="language-typescript">function numberwang(x: number | string): string {
  if (typeof x === &quot;number&quot;) {
    // in this block, `x: number`
    return `half of ${x * 2}`;
  } else {
    // in this block, `x: string`
    return `a string with ${x.length} characters`;
  }
}
</code></pre>
<pre><code class="language-typescript">class Dog {
  name: string;
  constructor(name: string) { this.name = name; }
}
class Car {
  wheels: number;
  constructor(wheels: number) { this.wheels = wheels; }
}

function description(x: Dog | Car): string {
  if (x instanceof Dog) {
    // in this block, `x: Dog`
    return `the dog ${x.name}`;
  } else {
    // in this block, `x: Car`
    return `a car with ${x.wheels} wheels`;
  }
}
</code></pre>
<p>However, runtime type tests are not always so simple. The following code
also typechecks in both Flow and TypeScript, yet does not necessarily
return an <code>Array&lt;T&gt;</code><sup class="footnote-reference"><a href="#flowbug">1</a></sup>:</p>
<pre><code class="language-typescript">function orSingleton&lt;T&gt;(x: T | Array&lt;T&gt;): Array&lt;T&gt; {
  if (x instanceof Array) {
    return x;
  }
  return [x];
}
</code></pre>
<p>While <code>x instanceof Array</code> does imply that <code>x: Array&lt;E&gt;</code> for some <code>E</code>,
it does not imply specifically that <code>x: Array&lt;T&gt;</code>, even when it is known
that <code>x: T | Array&lt;T&gt;</code>. The problem is that <code>T</code> could itself be
<code>Array&lt;U&gt;</code> for some type <code>U</code>, so <code>x: Array&lt;U&gt; | Array&lt;Array&lt;U&gt;&gt;</code> is an
instance of <code>Array</code> in either case:</p>
<pre><code class="language-typescript">// Purports to be the identity function, but fails when `x` happens to
// be an array.
function id&lt;T&gt;(x: T): T {
  const singletonArray: T[] = orSingleton(x);
  return singletonArray[0];
}

const digits: number[] = id([3, 1, 4]);
// unsound: `digits` is actually `3`
digits.includes(4);  // TypeError: digits.includes is not a function
</code></pre>
<p>In some sense, the core issue here is the refinement itself. A runtime
check that <code>x instanceof Array</code> says nothing about the element type of
the array, just as a runtime check that <code>typeof x === &quot;function&quot;</code> says
nothing about the domain or codomain. The untagged union type offers
a way to exploit this flaw. The same flaw occurred in Scala<sup class="footnote-reference"><a href="#dotty">2</a></sup>:</p>
<pre><code class="language-scala">// Counterexample by Lionel Parreaux
def test[A]: List[Int] | A =&gt; Int =
  { case ls: List[Int] =&gt; ls.head  case _ =&gt; 0 }
test(List(&quot;oops&quot;)) // crashes
</code></pre>
<p>By contrast, Typed Racket also supports refinements of union types, but
behaves correctly here:</p>
<pre><code class="language-racket">#lang typed/racket

(: valid-refinement (All (T) (U Number (Boxof T)) (-&gt; Number T) -&gt; T))
(define (valid-refinement x from-number)
  (if (box? x)
      (unbox x)  ;; works: must be a `Boxof T` (good)
      (from-number x)))

(: invalid-refinement (All (T) (U T (Boxof T)) -&gt; T))
(define (invalid-refinement x)
  (if (box? x)
      (unbox x)  ;; type error here: could be a box of something else (good!)
      x))
</code></pre>
<p>In Flow and TypeScript, this issue is resolved by using tagged
(disjoint) unions instead of untagged unions:</p>
<pre><code class="language-typescript">type ElementOrArray&lt;T&gt; =
  {type: &quot;ELEMENT&quot;, value: T} | {type: &quot;ARRAY&quot;, array: T[]};

function orSingleton&lt;T&gt;(x: ElementOrArray&lt;T&gt;): T[] {
  if (x.type === &quot;ARRAY&quot;) {
    return x.array;
  }
  return [x.value];
}

// Actually the identity function.
function id&lt;T&gt;(x: T): T {
  const singletonArray: T[] = orSingleton({type: &quot;ELEMENT&quot;, value: x});
  return singletonArray[0];
}
</code></pre>
<p>Since each variant of <code>ElementOrArray&lt;T&gt;</code> includes a distinct <code>type</code>
tag, there is no ambiguity in <code>orSingleton</code>, and the required changes to
<code>id</code> fix the bug.</p>
<p>In JavaScript, all values are in fact tagged as one of <code>&quot;string&quot;</code>,
<code>&quot;number&quot;</code>, <code>&quot;object&quot;</code>, or a few other options, and the <code>typeof</code>
operator exposes this tag at runtime. Thus, &quot;untagged&quot; unions like
<code>number | null</code> or <code>boolean | string</code>, where every variant has a
distinct value tag, are actually tagged unions, and may still be used
safely.</p>
<div class="footnote-definition" id="flowbug"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/facebook/flow/issues/6741">Refinement with <code>instanceof</code> and generic unions is unsound</a>, Flow issue #6741 (2018)</p>
</div>
<div class="footnote-definition" id="dotty"><sup class="footnote-definition-label">2</sup>
<p><a href="https://github.com/lampepfl/dotty/issues/5826">https://github.com/lampepfl/dotty/issues/5826</a> (2019)</p>
</div>
<h1><a class="header" href="#positivity-strict-and-otherwise" id="positivity-strict-and-otherwise">Positivity, strict and otherwise</a></h1>
<p><small><a href="glossary.html#recursive-types">[recursive-types]</a> <a href="glossary.html#totality">[totality]</a> <a href="glossary.html#impredicativity">[impredicativity]</a></small></p>
<p>In a total language, type definitions that refer to themselves must be restricted:</p>
<pre><code class="language-coq">-- rejected by Coq
Inductive bad := r (c : bad -&gt; nat).
</code></pre>
<pre><code class="language-agda">-- rejected by Agda
data Bad : Set where
  r : (Bad → ℕ) → Curry
</code></pre>
<p>Here, the type <code>bad</code> is defined recursively as consisting of a
function that accepts <code>bad</code> as an input. Allowing these <em>negative</em>
definitions leads to <a href="currys-paradox.html">Curry's paradox</a>, and breaks
totality.</p>
<p>The situation is more complicated if the recursive reference is
underneath two function arrows:</p>
<pre><code class="language-coq">-- also rejected by Coq
Inductive bad2 := r (c : (bad2 -&gt; nat) -&gt; nat).
</code></pre>
<pre><code class="language-agda">-- also rejected by Agda
data Bad2 : Set where
  r : ((Bad2 → ℕ) → ℕ) → Bad2
</code></pre>
<p>This is not negative recursion: <code>bad2</code> is not defined in terms of
functions that accept <code>bad2</code> values as an input, but in terms of
functions that may provide <code>bad2</code> values to their argument. This is
said to be positive recursion (since all recursive references to <code>bad2</code>
occur to the left of an <em>even</em> number of function arrows), but not
<em>strictly positive</em> (wherein all recursive references occur to the
left of <em>zero</em> function arrows).</p>
<p>Recursive definitions which are positive yet not strictly positive can
cause issues, as pointed out by Coquand and Paulin<sup class="footnote-reference"><a href="#colog88">1</a></sup>. Their
counterexample was translated into modern Coq by Sjöberg<sup class="footnote-reference"><a href="#sjöberg">2</a></sup>,
and reproduced here:</p>
<pre><code class="language-coq">(* Counterexample by Thierry Coquand and Christine Paulin
   Translated into Coq by Vilhelm Sjöberg *)

(* Phi is a positive, but not strictly positive, operator. *)
Definition Phi (a : Type) := (a -&gt; Prop) -&gt; Prop.

(* If we were allowed to form the inductive type
     Inductive A: Type :=
       introA : Phi A -&gt; A.
   then among other things, we would get the following. *)
Axiom A : Type.
Axiom introA : Phi A -&gt; A.
Axiom matchA : A -&gt; Phi A.
Axiom beta : forall x, matchA (introA x) = x.

(* In particular, introA is an injection. *)
Lemma introA_injective : forall p p', introA p = introA p' -&gt; p = p'.
Proof.
  intros.
  assert (matchA (introA p) = (matchA (introA p'))) as H1 by congruence.
  now repeat rewrite beta in H1.
Qed.

(* However, ... *) 

(* Proposition: For any type A, there cannot be an injection
   from Phi(A) to A. *)

(* For any type X, there is an injection from X to (X-&gt;Prop),
   which is λx.(λy.x=y) . *)
Definition i {X:Type} : X -&gt; (X -&gt; Prop) := 
  fun x y =&gt; x=y.

Lemma i_injective : forall X (x x' :X), i x = i x' -&gt; x = x'.
Proof.
  intros.
  assert (i x x = i x' x) as H1 by congruence.
  compute in H1.
  symmetry.
  rewrite &lt;- H1.
  reflexivity.
Qed.  

(* Hence, by composition, we get an injection f from A-&gt;Prop to A. *)
Definition f : (A-&gt;Prop) -&gt; A 
  := fun p =&gt; introA (i p).

Lemma f_injective : forall p p', f p = f p' -&gt; p = p'.
Proof.
  unfold f. intros.
  apply introA_injective in H. apply i_injective in H. assumption.
Qed.

(* We are now back to the usual Cantor-Russel paradox. *)
(* We can define *)
Definition P0 : A -&gt; Prop
  := fun x =&gt; 
       exists (P:A-&gt;Prop), f P = x /\ ~ P x.
  (* i.e., P0 x := x codes a set P such that x∉P. *)

Definition x0 := f P0.

(* We have (P0 x0) iff ~(P0 x0) *)
Lemma bad : (P0 x0) &lt;-&gt; ~(P0 x0).
Proof.
split.
  * intros [P [H1 H2]] H.
    change x0 with (f P0) in H1.
    apply f_injective in H1. rewrite H1 in H2.
    auto.
  * intros.
    exists P0. auto.
Qed.

(* Hence a contradiction. *)
Theorem worse : False.
  pose bad. tauto.
Qed.
</code></pre>
<!-- FIXME: "recursive" vs. "inductive" terminology -->
<p>This counterexample uses three ingredients: non-strictly-positive
definitions, impredicativity (the ability for definitions of terms in
<code>Prop</code> to quantify over all of <code>Prop</code>) and a universe type (the
ability to refer to <code>Prop</code> itself as a type). It appears that all
three are necessary:</p>
<ul>
<li>
<p>The Calculus of Inductive Constructions, upon which Coq is based,
is total, and has an impredicative <code>Prop</code> and a universe type for
<code>Prop</code>, but requires all inductive definitions to be strictly
positive.</p>
</li>
<li>
<p>System F is impredicative, and can encode (or be extended with)
non-strictly-positive inductive types while remaining total (see
Berger et al.<sup class="footnote-reference"><a href="#hofmann">3</a></sup> for an example), but lacks a universe type.</p>
</li>
<li>
<p>The combination of non-strictly-positive inductive types and
universe types is an unusual one, but poses no theoretical
problems in the absence of impredicativity. See for instance the
constructions of Abel<sup class="footnote-reference"><a href="#abel">4</a></sup> or Blanqui<sup class="footnote-reference"><a href="#blanqui">5</a></sup>.</p>
</li>
</ul>
<div class="footnote-definition" id="colog88"><sup class="footnote-definition-label">1</sup>
<p>Section 3.1 of &quot;Inductively defined types&quot;, Thierry Coquand and Christine Paulin, 1988.</p>
</div>
<div class="footnote-definition" id="sjöberg"><sup class="footnote-definition-label">2</sup>
<p><a href="http://vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive/">Why must inductive types be strictly positive?</a>, Vilhelm Sjöberg (2015) </p>
</div>
<div class="footnote-definition" id="hofmann"><sup class="footnote-definition-label">3</sup>
<p><a href="https://hal.archives-ouvertes.fr/hal-02365814">Martin Hofmann’s Case for Non-Strictly Positive Data Types</a>, Ulrich Berger, Ralph Matthes and Anton Setzer (2018)</p>
</div>
<div class="footnote-definition" id="abel"><sup class="footnote-definition-label">4</sup>
<p>Section 7.1 of <a href="http://www.cs.cmu.edu/%7Eabel/publications.html">A Semantic Analysis of Structural Recursion</a>, Andreas Abel (1999)</p>
</div>
<div class="footnote-definition" id="blanqui"><sup class="footnote-definition-label">5</sup>
<p><a href="https://arxiv.org/abs/cs/0610070">Inductive types in the Calculus of Algebraic Constructions</a>, Frédéric Blanqui (2006)</p>
</div>
<h1><a class="header" href="#nearly-universal-quantification" id="nearly-universal-quantification">Nearly-universal quantification</a></h1>
<p><small><a href="glossary.html#polymorphism">[polymorphism]</a> <a href="glossary.html#subtyping">[subtyping]</a></small></p>
<p>This issue is about an interaction between polymorphism and
<em>constrained type constructors</em>. These are a feature of several type
systems allowing the definition of a type constructor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mo>−</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T[-]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord">−</span><span class="mclose">]</span></span></span></span>, where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> is a valid type only for certain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>This feature is different from GADTs (indexed types), which allow the
definition of a type constructor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mo>−</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T[-]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord">−</span><span class="mclose">]</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> is always a valid
type, but one which is only inhabited for certain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>To explain this distinction, here's a GADT <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">G</mi></mrow><annotation encoding="application/x-tex">\n{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">G</span></span></span></span></span> and a constrained
type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">C</mi></mrow><annotation encoding="application/x-tex">\n{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">C</span></span></span></span></span>:</p>
<pre><code class="language-ocaml">type 'a g = G_int : { name : string } -&gt; int g

type 'a c = { name: string } constraint 'a = int
</code></pre>
<pre><code class="language-scala">sealed trait G[T]
case class G_int(i: Int) extends G[Int]

class C[A &gt;: Int &lt;: Int](name : String)
</code></pre>
<p>The type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">C</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{C}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">C</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> is only legal when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">A = \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>, whereas
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">G</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{G}[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">G</span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span> is always valid, but is an empty type unless <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">A = \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>:</p>
<pre><code class="language-ocaml">type ok = string g

type bad = string c
(* Error: This type string should be an instance of type int *)
</code></pre>
<pre><code class="language-scala">type Ok = G[String]

type Bad = C[String]
// Error: type arguments [A] do not conform to
// class C's type parameter bounds [A &gt;: Int &lt;: Int]
</code></pre>
<p>With constrained types, there are two different ways to interpret a
polymorphic type such as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mi mathvariant="sans-serif">C</mi><mo stretchy="false">[</mo><mi>α</mi><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">r</mi><mi mathvariant="sans-serif">i</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">g</mi></mrow></mrow><annotation encoding="application/x-tex">∀α. \n{C}[α] → \n{String}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord"><span class="mord mathsf">C</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">t</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span><span class="mord mathsf">i</span><span class="mord mathsf">n</span><span class="mord mathsf" style="margin-right:0.01389em;">g</span></span></span></span></span>:</p>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mo>…</mo></mrow><annotation encoding="application/x-tex">∀α.;\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> really means &quot;for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>&quot;, so the type above is
invalid since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">C</mi><mo stretchy="false">[</mo><mi>α</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\n{C}[α]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">C</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">]</span></span></span></span> is not a valid type for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>α</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mo>…</mo></mrow><annotation encoding="application/x-tex">∀α.;\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> means &quot;for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> for which the right-hand side is
valid&quot;, so the type above is valid, but can only be used with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">n</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">α
= \n{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">n</span><span class="mord mathsf">t</span></span></span></span></span>.</p>
</li>
</ol>
<p>Both OCaml and Scala choose option (1):</p>
<pre><code class="language-ocaml">let poly : 'a . 'a c -&gt; string =
  fun _ -&gt; &quot;hello&quot;
(* Error: The universal type variable 'a cannot be generalized:
          it is bound to int. *)
</code></pre>
<pre><code class="language-scala">def poly[A](x: C[A]): String = &quot;hello&quot;
// Error: type arguments [A] do not conform to
// class C's type parameter bounds [A &gt;: Int &lt;: Int]
</code></pre>
<p>Option (2) requires slightly less annotation by the programmer, but it
can be easy to lose track of the implicit constraints on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>. Rust
chooses this option, which led to a tricky bug <sup class="footnote-reference"><a href="#rust">1</a></sup>.</p>
<p>In Rust, the type <code>&amp;'a T</code> means a reference to type <code>T</code> which is valid
for lifetime <code>'a</code>. Lifetimes are ordered by a subtyping relation <code>'a: 'b</code> (pronounced &quot;<code>'a</code> outlives <code>'b</code>&quot;), if the lifetime <code>'a</code> contains
all of <code>'b</code>. References to references <code>&amp;'a &amp;'b T</code> are valid, but only
if <code>'b: 'a</code> as the reference's lifetime must not outlive its
contents.</p>
<p>There is also a longest lifetime <code>'static</code>, such that <code>'static: 'a</code>
for any lifetime <code>'a</code>. The bug allows any reference to be converted to
a <code>'static</code> reference, breaking soundness guarantees:</p>
<pre><code class="language-_rust">// Counterexample by Aaron Turon
static UNIT: &amp;'static &amp;'static () = &amp;&amp;();

fn foo&lt;'a, 'b, T&gt;(_: &amp;'a &amp;'b (), v: &amp;'b T) -&gt; &amp;'a T { v }

fn bad&lt;'c, T&gt;(x: &amp;'c T) -&gt; &amp;'static T {
    let f: fn(&amp;'static &amp;'c (), &amp;'c T) -&gt; &amp;'static T = foo;
    f(UNIT, x)
}
</code></pre>
<p>The issue is that the type of <code>foo</code> uses <code>&amp;'a &amp;'b ()</code>, which is a
well-formed type only if <code>'b: 'a</code>, as a reference cannot outlive its
contents. This constraint <code>'b: 'a</code> is relied upon, to allow <code>v</code> to be
returned.</p>
<p>Since Rust uses option (2) above, this constraint does not
appear explicitly in the type of <code>foo</code>:</p>
<pre><code class="language-_rust">fn foo&lt;'a, 'b, T&gt; (_: &amp;'a &amp;'b (), v: &amp;'b T) -&gt; &amp;'a T
</code></pre>
<p>Contravariance allows arguments to be passed with a longer lifetime
than required by the function, allowing <code>foo</code> to be used at the
following type, where one argument lifetime has been extended to
<code>'static</code>:</p>
<pre><code class="language-_rust">fn foo&lt;'a, 'b, T&gt; (_: &amp;'a &amp;'static (), v: &amp;'b T) -&gt; &amp;'a T
</code></pre>
<p>However, the implicit constraint <code>'b: 'a</code> has been lost, as validity
now requires only that <code>'static: 'a</code>, which is always true. This
allows the type to be instantiated with <code>'a := 'static</code>, <code>'b := 'c</code>:</p>
<pre><code class="language-_rust">fn foo&lt;T&gt; (_: &amp;'static &amp;'static (), v: &amp;'c T) -&gt; &amp;'static T
</code></pre>
<p>which is unsound.</p>
<div class="footnote-definition" id="rust"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/rust-lang/rust/issues/25860">https://github.com/rust-lang/rust/issues/25860</a> (2015)</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
